# Bem-vindo ao Terminal Matrix 🤖

```
 /\___/\   BASH CYBERPUNK LEARNING MATRIX v1.0
(=^.^=)   ================================
 (")_(")   Onde os hackers nascem...
```

## Aviso de Segurança Neural ⚠️

Tip:

Este tutorial contém altos níveis de:

* Comandos poderosos

* Humor nerd

* Referências geek

* Potencial para causar caos controlado

Prossiga por sua conta e risco.

## Manifesto do Terminal

Cansado de clicar em botões como um mero mortal?
Prepare-se para ascender ao próximo nível da existência computacional.
Aqui você aprenderá a domar o terminal e dobrar a matrix ao seu comando.

## O que te Aguarda

### 🎯 Sua Missão (caso aceite):

* Dominar a arte ancestral da linha de comando

* Automatizar tarefas mundanas

* Impressionar seus amigos com comandos obscuros

* Não destruir seu sistema (isso é importante)

### 💊 Escolha sua Pílula:

```
🔵 GUI Confortável    🔴 Terminal Matrix
     (boring)         (awesome)
```

## Pré-requisitos para a Jornada

* [x] Um terminal (duh!)

* [x] Dedos funcionais

* [x] Backup dos seus arquivos (confie em mim)

* [x] Disposição para aprender

* [x] Senso de humor

* [ ] Medo de tela preta

## Como Usar este Guia

### 📚 Estrutura do Conhecimento:

```
INICIANTE -> SOBREVIVENTE -> GUERREIRO -> MESTRE DO BASH
    |           |              |             |
 Módulo 1    Módulo 2       Módulo 3     Módulo 4
```

### 🎮 Em Cada Capítulo Você Encontrará:

* 📖 Teoria (o mínimo possível)

* 💻 Prática (o máximo possível)

* 🎯 Desafios (para testar sua coragem)

* 💡 Dicas (para não quebrar tudo)

* 🎵 Easter eggs (porque sim)

## Regras do Terminal Club

1. Não fale sobre `rm -rf /`

2. NÃO FALE SOBRE `rm -rf /`

3. Sempre tenha um backup

4. O terminal está sempre certo

5. Exceto quando não está

## Começando sua Jornada

```BASH
$ echo "Hello, brave terminal warrior!"
$ ./start_journey.sh
```

Tip:

"Com grandes poderes em Bash vêm grandes possibilidades de quebrar tudo"

* Tio Ben do Terminal

## Próximos Passos

Escolha seu destino:

* [Fundamentos do Bash](basics.html) - Para iniciantes corajosos

* [Comandos Essenciais](essential-commands.html) - Para aventureiros determinados

* [Scripts e Automação](scripting.html) - Para hackers em ascensão

* [Projetos Práticos](projects.html) - Para quem gosta de ação

Lembre-se: No terminal, ninguém pode ouvir você gritar... mas podem ver seus logs.

```
CARREGANDO MATRIX DO BASH...
[██████████████████████████] 100%
SISTEMA PRONTO. BOA SORTE.
```



# Fundamentos do Bash: Seu Primeiro Jack-In

```
< INICIANDO SEQUÊNCIA DE TREINAMENTO >
=====================================
     MÓDULO 1: FUNDAMENTOS
=====================================
```

## O que Você Vai Aprender Neste Módulo

Tip:

"Eu não posso te dizer o que é a Matrix. Você tem que ver por si mesmo."

* Morpheus do Terminal

### 🎯 Objetivos de Aprendizado

* Entender o que é o Bash e por que ele é poderoso

* Dominar a navegação básica no terminal

* Executar seus primeiros comandos sem destruir nada

* Compreender o sistema de arquivos como um verdadeiro hacker

## Roteiro de Treinamento

### 

1. [O que é Bash?](what-is-bash.html)

* História e origem

* Por que usar linha de comando?

* Bash vs outros shells

### 

2. [Básico do Terminal](terminal-basics.html)

* Anatomia do terminal

* Prompt de comando

* Sintaxe básica

* Auto-completar (seu melhor amigo)

### 

3. [Primeiros Comandos](first-commands.html)

* Comandos essenciais

* Flags e opções

* Manual de sobrevivência (man pages)

* Combinando comandos

### 

4. [Sistema de Arquivos](file-system.html)

* Estrutura de diretórios

* Navegação

* Manipulação básica de arquivos

* Permissões (não se mate ainda)

## Regras de Sobrevivência

```
REGRA #1: SEMPRE tenha um terminal de backup
REGRA #2: Quando em dúvida, --help
REGRA #3: Ctrl+C é seu botão de ejeção
```

## Dicas do Operador

💡 Protips:

* Tab é seu amigo. Tab duas vezes é seu melhor amigo

* As setas ↑↓ são sua máquina do tempo

* Ctrl+L limpa a tela (mas não seus erros)

* Quando tudo falhar, existe o Stack Overflow

## Exercícios de Iniciação

🎯 Desafios para Praticar:

1. Abra um terminal sem usar o mouse

2. Navegue pelos diretórios sem se perder

3. Leia uma man page sem dormir

4. Use tab-completion 10 vezes seguidas

## Checkpoint de Segurança

⚠️ Antes de Prosseguir, Verifique:

* [ ] Terminal funcionando

* [ ] Backup dos arquivos importantes

* [ ] Vontade de aprender

* [ ] Café na xícara

## Próximos Passos

Escolha seu próximo módulo de treinamento:

* [O que é Bash?](what-is-bash.html)

* [Básico do Terminal](terminal-basics.html)

* [Primeiros Comandos](first-commands.html)

* [Sistema de Arquivos](file-system.html)

Tip:

"Todo expert já foi um noob que decidiu não desistir."

* Antigo provérbio do Terminal

```
STATUS: MÓDULO 1 CARREGADO
[█████░░░░░░░░░░░] 25% COMPLETO
PRÓXIMA LIÇÃO AGUARDANDO INPUT...
```



# O que é Bash: Sua Primeira Pílula Vermelha 💊

Note:

O código de exemplo para este tópico está disponível em `code/module1/what-is-bash/version.sh`. Execute-o para ver uma demonstração prática dos conceitos apresentados aqui.

```
/bin/bash --version
=====================================
GNU bash, version 5.1.16(1)-release
=====================================
```

## A Origem da Matrix

Tip:

"No começo, havia a linha de comando. E era boa."

* Genesis do Unix, versículo 1

O Bash (Bourne Again Shell) nasceu em 1989, criado por Brian Fox para o Projeto GNU. É o sucessor espiritual do Thompson shell e do Bourne shell (sh), mas com superpoderes adicionais.

## Por Que o Bash é Especial?

### 🚀 Características Principais

* Shell padrão na maioria das distros Linux

* Compatível com scripts sh

* Extensível e personalizável

* Poderoso processamento de texto

* Automação de tarefas como um boss

## Bash vs. Outros Shells

```
COMPARAÇÃO DE SHELLS
===================
Bash  ████████████ [Versátil]
Zsh   ███████████░ [Customizável]
Fish  ██████████░░ [Amigável]
sh    ████████░░░░ [Minimalista]
```

### 🥊 Round 1: Bash vs GUI

| Bash |GUI |
-------------
| Rápido |Lento |
| Eficiente |Bonito |
| Scriptável |Clicável |
| Hackável |Limitado |

## Onde o Bash Vive

```BASH
# Localizações comuns do Bash
/bin/bash        # O executável principal
~/.bashrc        # Configurações do usuário
~/.bash_history  # Histórico de comandos
/etc/profile     # Configurações globais
```

## Por Que Aprender Bash?

### 💪 Superpoderes que Você Ganha

1. Automação de tarefas repetitivas

2. Controle total sobre o sistema

3. Debugging mais eficiente

4. Habilidades de administração de sistemas

5. Respeito da comunidade hacker

## Mitos e Verdades

### 🤔 Mitos

* "É só para hackers"

* "Vai substituir todas as GUIs"

* "Preciso memorizar tudo"

### ✅ Verdades

* É uma ferramenta poderosa

* Complementa interfaces gráficas

* A prática leva à perfeição

## Primeiros Passos no Terminal

```BASH
# Verifique sua versão do Bash
echo $BASH_VERSION

# Veja onde está instalado
which bash

# Execute seu primeiro comando
echo "Hello, Matrix!"
```

## Conceitos Básicos

### 🔤 Terminologia Essencial

* Shell: Interface de linha de comando

* Terminal: Emulador que roda o shell

* Prompt: Onde você digita comandos

* Script: Série de comandos em arquivo

## Preparando seu Ambiente

### ⚙️ Checklist de Iniciação

* [ ] Terminal instalado

* [ ] Bash configurado como shell padrão

* [ ] `.bashrc` localizado

* [ ] Permissões básicas configuradas

## Próximos Passos

Agora que você conhece o Bash, é hora de:

1. [Aprender os Básicos do Terminal](terminal-basics.html)

2. [Executar seus Primeiros Comandos](first-commands.html)

3. [Explorar o Sistema de Arquivos](file-system.html)

Tip:

"O Bash não é apenas um shell, é um estilo de vida."

* Hacker Anônimo

```
CARREGANDO PRÓXIMO MÓDULO...
[██████░░░░░░░░░░] 30% COMPLETO
CONHECIMENTO BASE ADQUIRIDO
```



# Fundamentos do Terminal

Note:

Aprenda os conceitos fundamentais para trabalhar eficientemente com o terminal.

```
USER@MATRIX:~$ _
=====================================
TERMINAL BÁSICO v1.0
STATUS: CONECTADO
MODO: INICIANTE
PERIGO: MODERADO
=====================================
```

## Anatomia do Terminal

### 🔍 Decodificando o Prompt

```BASH
usuario@maquina:~/pasta$ comando --opcao argumento
^       ^        ^     ^       ^      ^
|       |        |     |       |      |
|       |        |     |       |      └─ Argumentos/Parâmetros
|       |        |     |       └────────── Opções/Flags
|       |        |     └─────────────────── Comando
|       |        └─────────────────────────── Diretório Atual
|       └────────────────────────────────────── Nome da Máquina
└──────────────────────────────────────────────── Seu Username
```

## Elementos Básicos

### 🎯 Componentes Principais

* Prompt: Sua linha de comando na Matrix

* Cursor: O portal piscante entre dimensões

* Output: As respostas da Matrix

* Scrollback: Seus registros temporais

### 🎨 Cores e Estilos

```BASH
# Cores básicas
echo -e "\e[31mVermelho\e[0m"
echo -e "\e[32mVerde\e[0m"
echo -e "\e[33mAmarelo\e[0m"
echo -e "\e[34mAzul\e[0m"

# Estilos
echo -e "\e[1mNegrito\e[0m"
echo -e "\e[4mSublinhado\e[0m"
```

## Navegação Básica

### ⌨️ Atalhos Essenciais

| Atalho |Ação |Descrição |
---------------------------
| `Ctrl + C` |Cancelar |Interrompe o comando atual |
| `Ctrl + L` |Limpar |Limpa a tela (como `clear`) |
| `Ctrl + A` |Início |Move cursor para início da linha |
| `Ctrl + E` |Fim |Move cursor para fim da linha |
| `Ctrl + U` |Limpar Linha |Apaga do cursor até o início |
| `Ctrl + K` |Limpar Frente |Apaga do cursor até o fim |

## Navegação Avançada

### ⌨️ Combo de Atalhos (Modo Hacker)

| Combo |Efeito Especial |Nível de Poder |
------------------------------------------
| `Ctrl + R` + `Ctrl + R` |Pesquisa reversa recursiva |9000+ |
| `Alt + .` |Último argumento do comando anterior |8500+ |
| `Ctrl + X + E` |Abre comando atual no editor |7500+ |
| `Ctrl + W` |Deleta palavra anterior |6000+ |

### 🎮 Modo de Movimento

```BASH
# Navegação Ninja
Alt + F     # Avança uma palavra
Alt + B     # Retrocede uma palavra
Ctrl + XX   # Alterna entre início da linha e posição atual
```

## História e Autocompletar

### ⏳ Navegando no Tempo

```BASH
# Use as setas para navegar no histórico
↑ (Comando anterior)
↓ (Próximo comando)

# Pesquise no histórico
Ctrl + R (Digite para pesquisar)
```

### 🎯 Autocomplete: Seu Melhor Amigo

```BASH
# Pressione TAB para autocompletar
cd Doc[TAB]     # Completa para "Documents"
ls ~/Des[TAB]   # Completa para "Desktop"

# TAB duas vezes mostra todas as opções
ls --[TAB][TAB] # Mostra todas as flags disponíveis
```

## Customização Básica

### 🎨 Personalizando seu Terminal

```BASH
# Cores no prompt
export PS1="\[\033[32m\]\u@\h\[\033[00m\]:\[\033[34m\]\w\[\033[00m\]\$ "

# Aliases úteis
alias ll='ls -la'
alias cls='clear'
alias matrix='echo "Você está na Matrix agora!"'
```

## Customização Matrix

### 🛠️ Configuração do Ambiente

```BASH
# Personalize seu .bashrc
export PS1='\[\033[01;32m\][\u@\h\[\033[01;37m\] \W\[\033[01;32m\]]\$\[\033[00m\] '

# Aliases para Hackers
alias matrix='echo -e "\e[32m" && tr -c "[:digit:]" " " < /dev/urandom | dd cbs=$COLUMNS conv=unblock | GREP_COLOR="1;32" grep --color "[^ ]"'
alias hack='echo "Iniciando invasão..." && sleep 1 && tree /'
alias power='echo "Poder atual: $(( $RANDOM % 9000 + 1000 ))"'
```

### 🎵 Sons e Efeitos

```BASH
# Adicione feedback sonoro (requer beep)
alias alert='echo -e "\a"'
alias mission='echo "Missão completada" && beep -f 500 -l 100'
```

## Modo Multi-terminal

### 📺 Split Screen Powers

* tmux: Divisão de terminal matrix-style

* screen: Sessões persistentes

* terminator: Layout customizado

```BASH
# Comandos tmux básicos
tmux new -s matrix    # Nova sessão
tmux split-window -h  # Split horizontal
tmux split-window -v  # Split vertical
```

## Personalização Avançada

### 🎨 Temas e Cores

```BASH
# Esquemas de cores
export TERM=xterm-256color

# PS1 Cyberpunk
PS1='\[\e[1;32m\][\[\e[1;36m\]\u\[\e[1;32m\]@\[\e[1;36m\]\h\[\e[1;32m\]]\[\e[1;36m\]\w\[\e[1;32m\]\$\[\e[0m\] '
```

## Modo Debug

### 🔍 Ferramentas de Diagnóstico

```BASH
# Debugging básico
set -x           # Ativa modo debug
set +x           # Desativa modo debug
bash -x script.sh # Executa script em modo debug
```

## Dicas de Sobrevivência

### 💡 Protips para Iniciantes

1. Use TAB constantemente

2. Mantenha um olho no prompt

3. Leia as mensagens de erro

4. Quando em dúvida, use `--help`

## Exercícios Práticos

### 🎮 Mini-Desafios

1. Abra o terminal e identifique cada parte do prompt

2. Pratique os atalhos de teclado básicos

3. Crie três aliases personalizados

4. Use TAB para completar 10 comandos diferentes

## Exercícios de Poder

### 🎯 Desafios Matrix

1. Nível 1: Configure 3 aliases personalizados

2. Nível 2: Crie um PS1 customizado com cores

3. Nível 3: Configure tmux com splits

4. Nível 4: Crie um script que use cores

5. Boss Level: Combine todos os anteriores

## Troubleshooting Básico

### 🔧 Problemas Comuns

* Terminal travado? `Ctrl + C` ou `Ctrl + D`

* Comando errado? Use `history` para encontrar o correto

* Perdido? `pwd` mostra onde você está

* Comando não encontrado? Verifique o PATH

## Troubleshooting Avançado

### 🔧 Matrix Glitches

* Terminal corrompido? `reset` ou `tput reset`

* PS1 bugado? `export PS1='$ '` para reset

* Cores malucas? `echo -e "\e[0m"` para resetar

* Terminal travado? Sequência de escape: `Ctrl + Q`

## Easter Eggs

### 🎮 Comandos Secretos

```BASH
# Divirta-se
sl         # Steam Locomotive
cmatrix    # Modo Matrix
cowsay     # Vaca falante
fortune    # Mensagens da sorte
```

## Próximos Passos

Agora que você domina o básico do terminal, é hora de:

1. [Executar seus Primeiros Comandos](first-commands.html)

2. [Explorar o Sistema de Arquivos](file-system.html)

3. [Aprender sobre Permissões](null)

Tip:

"O terminal é como um lightsaber: uma arma elegante, de tempos mais civilizados."

* Obi-Wan KenTerminal

```
CARREGANDO PRÓXIMO MÓDULO...
[████████░░░░░░░░] 40% COMPLETO
INTERFACE NEURAL SINCRONIZADA
PODER TERMINAL: AUMENTANDO
MATRIX: ESTÁVEL
```



# Primeiros Comandos: Hackeando a Matrix 🚀

Note:

Confira o script de exemplo em `code/module1/first-commands/basic_operations.sh` para ver uma demonstração prática das operações básicas com arquivos e diretórios.

```
INICIANDO SEQUÊNCIA DE COMANDOS...
==================================
STATUS: PRONTO PARA HACKEAR
NÍVEL DE ACESSO: INICIANTE
PERIGO: BAIXO (por enquanto)
==================================
```

## Comandos Básicos de Sobrevivência

### 🔍 Reconhecimento do Terreno

#### PWD (Print Working Directory)

```BASH
pwd     # Mostra o caminho completo do diretório atual
pwd -P  # Mostra o caminho físico (resolve links simbólicos)
pwd -L  # Mostra o caminho lógico (padrão)
```

#### LS (List)

```BASH
ls              # Lista arquivos e diretórios
ls -l           # Formato longo com detalhes
ls -a           # Mostra arquivos ocultos
ls -h           # Tamanhos legíveis (1K, 234M, 2G)
ls -R           # Lista recursiva
ls -lart        # Combinação: long, hidden, reverse, time
```

#### CD (Change Directory)

```BASH
cd              # Vai para o diretório home
cd -            # Volta para o último diretório
cd ..           # Sobe um nível
cd ../../       # Sobe dois níveis
cd ~/Documents  # Caminho absoluto
cd ./pasta      # Caminho relativo
```

#### CLEAR

```BASH
clear           # Limpa a tela
Ctrl + L        # Atalho para limpar
reset           # Reinicia o terminal completamente
```

### 📂 Operações de Arquivo Avançadas

#### TOUCH

```BASH
touch arquivo.txt          # Cria arquivo ou atualiza timestamp
touch -t 202312311200     # Define data/hora específica
touch -r ref.txt novo.txt # Copia timestamp de outro arquivo
```

#### CAT (Concatenate)

```BASH
cat arquivo.txt           # Mostra conteúdo
cat -n arquivo.txt       # Mostra números das linhas
cat -b arquivo.txt       # Numera apenas linhas não vazias
cat arq1.txt arq2.txt    # Concatena arquivos
cat > arquivo.txt        # Cria arquivo e aguarda input
```

#### CP (Copy)

```BASH
cp origem.txt destino.txt     # Copia arquivo
cp -r pasta1 pasta2          # Copia diretório recursivamente
cp -i arquivo.txt backup/    # Modo interativo
cp -u *.txt destino/         # Copia apenas arquivos mais novos
cp -v arquivo.txt ~/backup/  # Modo verbose
```

#### MV (Move)

```BASH
mv arquivo.txt ~/Documents/   # Move arquivo
mv arquivo.txt novo_nome.txt # Renomeia arquivo
mv -i *.txt destino/         # Modo interativo
mv -u *.txt destino/         # Move apenas arquivos mais novos
mv -v arquivo.txt ~/backup/  # Modo verbose
```

## Modo Tutorial Interativo Expandido

### 🎮 Mini-Game: Dominando o Terminal

#### Nível 1: Reconhecimento Básico

```BASH
# Missão: Explorar o Território
pwd                         # Identifique sua localização
ls -la                     # Analise o ambiente detalhadamente
cd ~                       # Retorne à base (home)
clear                      # Limpe seus rastros

# Checkpoint 1: Navegação Avançada
cd /                       # Vá para a raiz do sistema
ls -lh                     # Analise com tamanhos legíveis
cd /etc                    # Entre no diretório de configurações
cd -                       # Volte ao último diretório
```

#### Nível 2: Manipulação de Arquivos

```BASH
# Missão: Criar sua Base de Operações
mkdir operacao_alpha       # Crie sua base secreta
cd operacao_alpha         # Entre na base
touch log.txt config.txt   # Crie arquivos de missão
ls -la                    # Verifique a criação

# Checkpoint 2: Modificação de Arquivos
echo "Início da missão" > log.txt     # Adicione conteúdo
echo "Status: Ativo" >> log.txt       # Append conteúdo
cat log.txt                           # Verifique o conteúdo
cp log.txt backup_log.txt            # Crie backup
```

#### Nível 3: Operações Combinadas

```BASH
# Missão: Manipulação Avançada
mkdir -p projetos/{alfa,beta,gamma}   # Crie estrutura complexa
touch projetos/{alfa,beta,gamma}/readme.txt  # Múltiplos arquivos
ls -R projetos                        # Verifique estrutura
find projetos -name "*.txt"          # Localize arquivos
```

## Comandos de Informação Detalhados

### 📊 Status e Ajuda Avançada

#### Informações do Sistema

```BASH
date                  # Data e hora atual
date +"%Y-%m-%d"     # Formato personalizado
whoami               # Usuário atual
id                   # Informações de ID do usuário
uname -a             # Todas as informações do sistema
hostname             # Nome do computador
```

#### Ajuda e Documentação

```BASH
man comando          # Manual completo
comando --help       # Ajuda rápida
info comando         # Documentação detalhada
whatis comando       # Descrição curta
whereis comando      # Localiza binário, fonte e manual
```

### 💡 Dicas Rápidas Avançadas

| Comando |Descrição |Nível de Poder |Exemplo |
-----------------------------------------------
| `!!` |Repete último comando |⚡⚡ |`sudo !!` |
| `!$` |Último argumento |⚡⚡⚡ |`mkdir pasta && cd !$` |
| `!*` |Todos argumentos |⚡⚡⚡ |`echo !*` |
| `!:n` |n-ésimo argumento |⚡⚡⚡⚡ |`!:2` |
| `^old^new` |Substitui no último comando |⚡⚡⚡⚡ |`^foo^bar` |
| `history` |Histórico de comandos |⚡⚡⚡⚡ |`history \\| grep git` |

## Primeiros Scripts Avançados

### 🛠️ Scripts de Poder

#### Script de Backup Básico

```BASH
#!/bin/bash
# backup_script.sh
echo "Iniciando backup..."

# Variáveis
SOURCE_DIR="$HOME/Documents"
BACKUP_DIR="$HOME/Backups"
DATE=$(date +%Y%m%d)

# Criar diretório de backup
mkdir -p "$BACKUP_DIR"

# Realizar backup
tar -czf "$BACKUP_DIR/backup_$DATE.tar.gz" "$SOURCE_DIR"

echo "Backup completo: backup_$DATE.tar.gz"
```

#### Script de Monitoramento

```BASH
#!/bin/bash
# monitor.sh
echo "Monitorando sistema..."

# Informações do sistema
echo "CPU Usage:"
top -bn1 | head -n 3

echo "Memory Usage:"
free -h

echo "Disk Usage:"
df -h
```

## Combinando Comandos - Técnicas Avançadas

### 🔗 Operadores e Redirecionamento

#### Operadores Lógicos

```BASH
# AND (&&) - Execução condicional
mkdir projeto && cd projeto && touch readme.md

# OR (||) - Fallback
ping -c 1 google.com || echo "Sem conexão"

# Semicolon (;) - Execução sequencial
echo "Início" ; sleep 2 ; echo "Fim"
```

#### Redirecionamento

```BASH
# Output redirection
echo "log entry" > log.txt      # Sobrescreve
echo "new entry" >> log.txt     # Append
ls /naoexiste 2> erro.log      # Redireciona erro

# Pipe
ps aux | grep bash             # Filtra processos
ls -la | sort -k5 -n          # Ordena por tamanho
cat arquivo.txt | wc -l       # Conta linhas
```

## Exercícios Práticos Avançados

### 🎯 Missões de Elite

#### Missão #1: Reconhecimento Avançado

```BASH
# Objetivo: Mapeamento completo do sistema
pwd
ls -laR | grep "^d"           # Lista todos diretórios
find . -type f -mtime -1      # Arquivos modificados hoje
du -sh * | sort -hr          # Uso de disco ordenado
```

#### Missão #2: Manipulação Avançada

```BASH
# Objetivo: Gerenciamento de arquivos
mkdir -p projeto/{src,docs,tests}
touch projeto/src/{main,util,helper}.sh
chmod +x projeto/src/*.sh
find projeto -type f -name "*.sh" -exec ls -l {} \;
```

#### Missão #3: Automação Básica

```BASH
# Objetivo: Criar script de automação
cat << 'EOF' > auto_task.sh
#!/bin/bash
echo "Iniciando automação..."
for file in *.txt; do
    echo "Processando $file..."
    cp "$file" "backup_$file"
done
echo "Automação concluída!"
EOF
chmod +x auto_task.sh
```

## Troubleshooting Avançado

### 🔧 Resolução de Problemas Comuns

#### Problemas de Permissão

```BASH
# Verificar permissões
ls -la arquivo.txt
# Modificar permissões
chmod u+x script.sh
# Mudar proprietário
sudo chown user:group arquivo.txt
```

#### Problemas de Comando

```BASH
# Verificar existência do comando
which comando
# Verificar PATH
echo $PATH
# Atualizar PATH
export PATH=$PATH:/novo/caminho
```

#### Problemas de Processo

```BASH
# Listar processos
ps aux | grep processo
# Matar processo
kill -9 PID
# Verificar uso de recursos
top
```

## Power-Ups Avançados (Aliases e Funções)

### ⚡ Configurações de Poder

#### Aliases Avançados

```BASH
# Adicione ao .bashrc
alias ll='ls -la'
alias mkdir='mkdir -p'
alias ports='netstat -tulanp'
alias update='sudo apt update && sudo apt upgrade'
alias gh='history | grep'
```

#### Funções Úteis

```BASH
# Função para criar e entrar em diretório
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Função para backup rápido
bkp() {
    cp "$1" "$1.bak"
}

# Função para extrair arquivos
extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)          echo "'$1' não pode ser extraído via extract()" ;;
        esac
    else
        echo "'$1' não é um arquivo válido"
    fi
}
```

## Próximos Passos

Agora que você domina os comandos básicos e avançados:

1. [Explore o Sistema de Arquivos](file-system.html)

* Estrutura de diretórios

* Links simbólicos

* Gerenciamento de espaço

2. [Aprenda sobre Permissões](null)

* Permissões básicas e avançadas

* ACLs

* Sticky bits

3. [Domine o Processamento de Texto](text-processing.html)

* sed

* awk

* grep avançado

4. [Automação com Scripts](scripting.html)

* Loops

* Condicionais

* Funções

Tip:

"O terminal é como um lightsaber: uma arma elegante, de tempos mais civilizados."

* Obi-Wan KenTerminal

```
PROGRESSO DE TREINAMENTO...
[██████████████████] 90%
STATUS: HACKER EM FORMAÇÃO
PRÓXIMO NÍVEL: MESTRE DO TERMINAL

CARREGANDO MÓDULOS AVANÇADOS...
==============================
PODER: AUMENTANDO
CONHECIMENTO: EXPANDINDO
TERMINAL: DOMINADO
```



# Sistema de Arquivos: Navegando na Matrix 📁

Note:

Experimente o script interativo em `code/module1/file-system/file_explorer.sh` para uma exploração prática do sistema de arquivos e suas operações.

```
MAPEANDO ESTRUTURA DA MATRIX...
==============================
/
├── bin/
├── etc/
├── home/
└── usr/

STATUS: ESCANEANDO DIRETÓRIOS
NÍVEL DE ACESSO: INTERMEDIÁRIO
```

## Anatomia do Sistema de Arquivos

### 🌲 A Árvore de Diretórios

```BASH
/                   # Raiz do sistema
├── bin/            # Binários essenciais
├── boot/           # Arquivos de inicialização
├── dev/            # Dispositivos
├── etc/            # Configurações do sistema
├── home/           # Diretórios dos usuários
├── lib/            # Bibliotecas compartilhadas
├── media/          # Mídias removíveis
├── mnt/            # Montagens temporárias
├── opt/            # Pacotes opcionais
├── proc/           # Processos do sistema
├── root/           # Home do superusuário
├── run/            # Dados de runtime
├── sbin/           # Binários do sistema
├── srv/            # Dados de serviços
├── sys/            # Sistema
├── tmp/            # Arquivos temporários
├── usr/            # Programas do usuário
└── var/            # Dados variáveis
```

## Navegação Avançada

### 🗺️ Comandos de Navegação Pro

```BASH
pwd                     # Mostra diretório atual
cd -                    # Volta ao diretório anterior
cd ~                    # Vai para home
cd ..                   # Sobe um nível
pushd /path/to/dir     # Empilha diretório
popd                   # Desempilha diretório
```

### 🔍 Buscando na Matrix

```BASH
find / -name "*.log"    # Busca por nome
locate arquivo.txt      # Busca rápida (requer updatedb)
which comando           # Localiza executável
whereis programa       # Localiza binários e manuais
```

## Manipulação de Arquivos e Diretórios

### 📂 Operações Básicas

```BASH
touch arquivo.txt       # Cria arquivo vazio
mkdir -p dir1/dir2     # Cria diretórios recursivamente
cp -r origem destino   # Copia recursivamente
mv origem destino      # Move/renomeia
rm -rf diretorio       # Remove recursivamente (cuidado!)
```

### 🔗 Links e Atalhos

```BASH
ln arquivo hard_link    # Link físico
ln -s arquivo soft_link # Link simbólico
readlink link          # Mostra destino do link
```

## Análise do Sistema de Arquivos

### 📊 Comandos de Análise

```BASH
df -h                  # Uso do disco
du -sh *              # Tamanho dos arquivos
stat arquivo          # Detalhes do arquivo
file arquivo          # Tipo do arquivo
lsof                  # Arquivos abertos
```

### 🔬 Monitoramento

```BASH
inotifywait -m /path  # Monitora mudanças
ncdu                  # Análise de uso do disco
tree                  # Visualiza estrutura
```

## Permissões e Propriedade

### 🔒 Sistema de Permissões

```BASH
chmod 755 arquivo     # Modifica permissões
chown user:group arq  # Muda proprietário
chgrp grupo arquivo  # Muda grupo
umask 022            # Define máscara
```

### 📋 Interpretando Permissões

```
rwxr-xr--  1 user group  4096  Jan 1 12:00 arquivo
│││││││││
│││││││└└─ outros (r--)
│││││└└── grupo (r-x)
│└└└└─── dono  (rwx)
└────── tipo (-)
```

## Exercícios Práticos

### 🎯 Missão: Exploração do Sistema

1. Reconhecimento

```BASH
# Mapeie sua home
tree ~/ -L 2
# Liste arquivos ocultos
ls -la ~/
# Encontre arquivos grandes
find ~/ -size +100M
```

1. Manipulação

```BASH
# Crie estrutura de diretórios
mkdir -p projeto/{src,docs,tests}
# Crie links simbólicos
ln -s ~/projeto/src ~/src-link
# Archive diretórios
tar -czf backup.tar.gz ~/projeto
```

1. Análise

```BASH
# Analise uso do disco
du -sh */
# Verifique tipos de arquivo
file *
# Monitore mudanças
watch -n 1 'ls -l'
```

## Troubleshooting

### 🔧 Problemas Comuns

* Permissão negada: Use `sudo` ou verifique permissões

* Disco cheio: Use `df -h` e `du -sh *`

* Arquivo não encontrado: Verifique `$PATH` e permissões

* Link quebrado: Use `find -L -type l`

## Power-Ups (Aliases)

### ⚡ Aliases para Navegação

```BASH
# Adicione ao .bashrc
alias ll='ls -la'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias tree='tree --dirsfirst -C'
```

## Próximos Passos

Agora que você domina o sistema de arquivos:

1. [Aprenda sobre Permissões](null)

2. [Explore o Processamento de Texto](text-processing.html)

3. [Domine os Scripts](scripting.html)

Tip:

"O sistema de arquivos é como a Matrix - está em todo lugar, é o que você vê, o que você não vê, e tudo que está entre eles."

* Morpheus do Terminal

```
ANÁLISE DO SISTEMA CONCLUÍDA
[████████████████] 100%
STATUS: MAPEAMENTO COMPLETO
MATRIZ DE ARQUIVOS: DOMINADA
```



# Comandos Essenciais

Note:

Os códigos de exemplo para este módulo estão disponíveis em `code/module2/`. Cada subdiretório contém scripts práticos para você experimentar.

```
CARREGANDO ARSENAL DE COMANDOS...
================================
STATUS: FERRAMENTAS PREPARADAS
NÍVEL: INTERMEDIÁRIO
PODER: AUMENTANDO
================================
```

## Visão Geral

Neste módulo, você vai dominar as ferramentas essenciais do terminal, expandindo seu arsenal de comandos para:

* Navegar pelo sistema como um ninja 🥷

* Manipular arquivos com precisão cirúrgica 🎯

* Processar texto como um mestre Jedi ⚔️

* Extrair informações do sistema como um hacker de elite 🕵️

## Tópicos do Módulo

### 

1. [Comandos de Navegação](navigation-commands.html)

* Navegação avançada com `cd`, `pushd`, `popd`

* Buscas com `find` e `locate`

* Atalhos e truques de navegação

* Gerenciamento de diretórios

### 

2. [Operações com Arquivos](file-operations.html)

* Manipulação avançada com `cp`, `mv`, `rm`

* Compactação e descompactação

* Links simbólicos e hardlinks

* Gerenciamento de permissões

### 

3. [Processamento de Texto](text-processing.html)

* Filtragem com `grep`

* Transformação com `sed`

* Processamento com `awk`

* Ordenação e contagem

### 

4. [Informações do Sistema](system-info.html)

* Monitoramento com `top` e `htop`

* Análise de disco com `df` e `du`

* Gerenciamento de processos

* Informações de rede

## Ferramentas Essenciais

```BASH
# Navegação Avançada
find / -name "*.log" 2>/dev/null    # Busca todos os logs
locate "*.conf"                      # Localiza configs
which python3                        # Onde está o executável?
whereis bash                         # Onde está tudo do bash?

# Operações com Arquivos
tar -czf backup.tar.gz ./docs       # Compacta
tar -xzf backup.tar.gz              # Descompacta
rsync -av source/ dest/             # Sincroniza diretórios
dd if=/dev/zero of=test bs=1M count=100  # Cria arquivo de teste

# Processamento de Texto
grep -r "TODO" .                    # Busca recursiva
sed 's/antigo/novo/g' arquivo.txt   # Substitui texto
awk '{print $1}' dados.txt          # Extrai primeira coluna
sort -u números.txt                 # Ordena e remove duplicatas

# Informações do Sistema
ps aux | grep nginx                 # Processos específicos
netstat -tulpn                      # Portas abertas
free -h                            # Memória disponível
uptime                             # Tempo ligado
```

## Dicas de Poder

### 🎯 Combinando Comandos

```BASH
# Pipeline de processamento
find . -type f -name "*.log" | \
  xargs grep "ERROR" | \
  sort | uniq -c | \
  sort -nr
```

### ⚡ Atalhos de Teclado

* `Ctrl + R`: Busca no histórico

* `Alt + .`: Último argumento

* `Ctrl + W`: Apaga última palavra

* `Ctrl + U`: Apaga linha inteira

## Exercícios Práticos

### 🎓 Missões de Treinamento

1. Navegação Ninja

* Encontre todos os arquivos modificados hoje

* Liste apenas diretórios em uma árvore profunda

* Localize todos os executáveis no PATH

2. Manipulação de Arquivos

* Crie um backup compactado de uma estrutura

* Sincronize dois diretórios

* Encontre e remova arquivos duplicados

3. Processamento de Dados

* Extraia endereços IP de um log

* Conte ocorrências de palavras em múltiplos arquivos

* Substitua texto em vários arquivos

4. Análise do Sistema

* Monitore uso de CPU por processo

* Verifique espaço em disco por diretório

* Liste todas as conexões de rede ativas

## Próximos Passos

Depois de dominar estes comandos essenciais, você estará pronto para:

1. [Automação com Scripts](scripting.html)

2. [Administração do Sistema](system-admin.html)

3. [Redes e Conectividade](null)

Tip:

"Com grandes comandos vem grandes responsabilidades."

* Uncle Terminal

```
CARREGAMENTO CONCLUÍDO
[████████████████] 100%
STATUS: ARSENAL PREPARADO
PODER: INTERMEDIÁRIO
PRÓXIMA MISSÃO: AGUARDANDO...
```



# Comandos de Navegação

Note:

Os códigos de exemplo para esta seção estão disponíveis em `code/module2/navigation/basic_navigation.sh`. Execute e experimente cada comando para melhor compreensão.

```
CARREGANDO COMANDOS DE NAVEGAÇÃO...
==================================
STATUS: MAPEAMENTO ATIVO
NÍVEL: EXPLORADOR
==================================
```

Neste módulo, você aprenderá a navegar pelo sistema de arquivos com a eficiência de um ninja. Os tópicos incluem:

* Comandos básicos de navegação

* Técnicas avançadas de movimentação

* Gerenciamento de pilha de diretórios

* Busca eficiente com find e locate

* Uso de wildcards e globbing

* Atalhos e truques de navegação

* Automação de navegação

* Resolução de problemas comuns

Escolha um tópico para começar sua jornada rumo ao domínio da navegação no terminal.



# Fundamentos da Navegação 🎯

## Conceitos Básicos

### PWD - Print Working Directory

```BASH
pwd                     # Mostra diretório atual
pwd -P                 # Mostra caminho físico (resolve links simbólicos)
pwd -L                 # Mostra caminho lógico (padrão)
echo $PWD              # Variável de ambiente do diretório atual
```

### LS - List Directory Contents

```BASH
# Listagens básicas
ls                      # Lista simples
ls -l                   # Formato longo
ls -a                   # Mostra arquivos ocultos
ls -h                   # Tamanhos legíveis (human-readable)
ls -R                   # Lista recursiva
ls -S                   # Ordena por tamanho
ls -t                   # Ordena por data de modificação
ls -X                   # Ordena por extensão

# Combinações úteis
ls -lah                 # Listagem completa e legível
ls -ltr                 # Ordem reversa por data
ls -ld */               # Lista apenas diretórios
ls -1                   # Uma entrada por linha
```

### CD - Change Directory

```BASH
# Navegação básica
cd /                    # Vai para raiz
cd ~                    # Home do usuário
cd                      # Também vai para home
cd ..                   # Sobe um nível
cd -                    # Último diretório

# Navegação avançada
cd ~/Documents          # Caminho relativo ao home
cd "Pasta Com Espaços"  # Caminhos com espaços
cd ../pasta_irmã        # Navegação relativa
```

## Truques e Dicas

### Autocompletar

```BASH
# Use TAB para:
cd /e<TAB>             # Completa para /etc
cd /u/l/b<TAB>         # Completa caminhos longos
ls *.p<TAB>            # Completa arquivos por padrão
```

### Histórico de Navegação

```BASH
history | grep cd      # Mostra comandos cd anteriores
!!                     # Repete último comando
!cd                    # Repete último comando cd
```

### Atalhos do Shell

```BASH
CTRL + L               # Limpa a tela
CTRL + W               # Apaga última palavra
CTRL + U               # Apaga linha inteira
CTRL + A               # Início da linha
CTRL + E               # Fim da linha
```

## Configurações Úteis

### Aliases de Navegação

```BASH
# Adicione ao seu .bashrc
alias ll='ls -lah'
alias la='ls -A'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
```

### Funções de Navegação

```BASH
# Função para criar e entrar em diretório
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Função para voltar N diretórios
up() {
    local d=""
    limit=$1
    for ((i=1 ; i <= limit ; i++))
        do
            d=$d/..
        done
    d=$(echo $d | sed 's/^\///')
    if [ -z "$d" ]; then
        d=..
    fi
    cd $d
}
```

## Exercícios Práticos

### Nível Iniciante

1. Liste todos os arquivos no seu diretório home, incluindo ocultos

2. Navegue até /etc e liste seu conteúdo em formato longo

3. Volte para seu diretório home usando diferentes métodos

4. Use pwd para verificar sua localização após cada movimento

### Nível Intermediário

1. Crie uma estrutura de diretórios aninhada e navegue por ela

2. Use ls com diferentes combinações de flags

3. Pratique o uso de autocompletar em caminhos longos

4. Experimente os atalhos do shell

### Nível Avançado

1. Configure aliases personalizados para navegação

2. Crie funções de navegação customizadas

3. Implemente um sistema de bookmarks para diretórios

4. Pratique navegação usando apenas atalhos do teclado

## Troubleshooting Comum

### Problemas e Soluções

```BASH
# Permissão negada
ls -ld /caminho        # Verificar permissões
sudo ls /caminho       # Acessar com privilégios

# Diretório não encontrado
pwd                    # Confirmar localização atual
ls -la ..             # Verificar diretório pai
find / -name "dir"    # Procurar diretório perdido
```

## Dicas de Produtividade

1. Use o histórico do shell sabiamente

2. Aprenda os atalhos do teclado

3. Configure aliases para comandos frequentes

4. Mantenha uma estrutura de diretórios organizada

5. Use autocompletar sempre que possível

Tip:

"A navegação eficiente no terminal é como um superpoder - quanto mais você pratica, mais poderoso se torna."



# Navegação Avançada

Note:

Técnicas avançadas e ferramentas para navegação eficiente no sistema de arquivos.

## Técnicas Avançadas de CD

### Navegação Contextual

```BASH
cd -                   # Alterna entre último diretório
cd ~-                  # Expande para último diretório
cd ~+                  # Expande para diretório atual
cd ~usuario            # Home de outro usuário
cd "$(dirname "$0")"   # Diretório do script atual
```

### Navegação com Variáveis

```BASH
# Variáveis de ambiente
echo $OLDPWD           # Último diretório
echo $PWD              # Diretório atual
echo $HOME             # Diretório home

# Variáveis customizadas
export PROJETOS=~/projetos
export LOGS=/var/log
cd $PROJETOS
```

### Navegação com Substituição

```BASH
# Substituição de comando
cd $(git rev-parse --show-toplevel)  # Raiz do git
cd "$(dirname "$(readlink -f "$0")")" # Dir real do script
cd "$(find . -name 'target' -type d)" # Resultado de busca
```

## Técnicas de Busca e Navegação

### Find Avançado

```BASH
# Navegação baseada em resultados
cd "$(find . -name 'pom.xml' -type f -exec dirname {} \;)"
cd "$(find . -type d -name 'src' | head -1)"
```

### CDPATH

```BASH
# Configurando CDPATH
export CDPATH=.:~/projetos:/var/www:/opt
cd projeto-x   # Procura em todos os caminhos do CDPATH
```

## Automação de Navegação

### Bookmarks de Diretório

```BASH
# Sistema de bookmarks
export DIR_BOOKMARKS=~/.dir_bookmarks

# Função para adicionar bookmark
bookmark() {
    echo "$(pwd)" >> "$DIR_BOOKMARKS"
}

# Função para ir para bookmark
goto() {
    local dir=$(grep -i "$1" "$DIR_BOOKMARKS" | head -1)
    if [ -d "$dir" ]; then
        cd "$dir"
    else
        echo "Bookmark não encontrado"
    fi
}
```

### Navegação por Projeto

```BASH
# Função para navegar entre projetos
project() {
    case $1 in
        web) cd ~/projetos/web ;;
        api) cd ~/projetos/api ;;
        docs) cd ~/projetos/documentacao ;;
        *) echo "Projeto não encontrado" ;;
    esac
}
```

## Integração com Ferramentas

### Git Navigation

```BASH
# Funções para navegação em repositórios git
cdroot() {
    cd "$(git rev-parse --show-toplevel)"
}

cdbranch() {
    git checkout $1
    cdroot
}
```

### Docker Navigation

```BASH
# Funções para navegação em containers
cdcontainer() {
    docker exec -it $1 /bin/bash
}
```

## Stack Navigation Avançada

### Pilha Customizada

```BASH
# Implementação avançada de pilha
declare -a DIR_STACK

pushd_custom() {
    DIR_STACK+=("$(pwd)")
    cd "$1"
}

popd_custom() {
    if [ ${#DIR_STACK[@]} -gt 0 ]; then
        local last_index=$((${#DIR_STACK[@]}-1))
        cd "${DIR_STACK[$last_index]}"
        unset 'DIR_STACK[$last_index]'
    fi
}
```

## Exercícios Avançados

### Nível Expert

1. Implemente um sistema de navegação baseado em tags

2. Crie uma função para navegar pelo histórico de diretórios

3. Desenvolva um menu interativo para navegação rápida

4. Integre navegação com ferramentas de desenvolvimento

### Desafios de Automação

1. Crie um script que mantém um log de diretórios visitados

2. Implemente navegação baseada em frequência de uso

3. Desenvolva um sistema de aliases dinâmicos

4. Crie uma função de busca e navegação combinada

## Dicas de Performance

1. Use cache de diretórios frequentes

2. Implemente completion customizado

3. Mantenha histórico de navegação

4. Use atalhos de teclado personalizados

5. Automatize padrões de navegação comuns

Tip:

"A verdadeira maestria na navegação do terminal vem da combinação de velocidade e precisão."



# Pilha de Diretórios 📚

## Comandos da Pilha

```BASH
pushd /var/log        # Empilha diretório atual e vai para /var/log
pushd /etc           # Empilha novamente
dirs                 # Mostra a pilha
popd                # Volta para o último diretório empilhado
dirs -v             # Mostra pilha numerada
pushd +2            # Vai para posição 2 da pilha
pushd -n            # Empilha sem mudar de diretório
dirs -c             # Limpa a pilha
```

## Usos Práticos

```BASH
# Salvando múltiplos caminhos
pushd ~/projetos
pushd /var/log
pushd /etc/nginx
dirs -v             # Ver todos os caminhos salvos
popd               # Voltar na ordem inversa
```

## Exercícios

1. Crie uma pilha com 3 diretórios diferentes

2. Navegue entre eles usando pushd +n

3. Limpe a pilha e comece uma nova



# Find e Locate: Buscas Avançadas 🔍

## Find - O Rastreador Supremo

```BASH
# Busca por nome
find . -name "*.log"              # Busca recursiva por logs
find . -iname "*.LOG"            # Case insensitive
find . -not -name "*.tmp"        # Exclusão
find . -path "*src*"            # Busca no caminho

# Busca por tipo
find . -type f                   # Apenas arquivos
find . -type d                   # Apenas diretórios
find . -type l                   # Apenas links simbólicos

# Busca por tempo
find . -mtime -7                 # Modificados nos últimos 7 dias
find . -mmin -60                # Modificados na última hora
```

## Locate - O Velocista

```BASH
# Configuração e atualização
sudo updatedb                    # Atualiza banco de dados
locate -S                       # Estatísticas do banco

# Buscas básicas
locate arquivo.txt              # Busca rápida
locate -i ARQUIVO.TXT          # Case insensitive
locate -e arquivo.txt         # Verifica existência
```

## Exercícios

1. Encontre todos os arquivos .log modificados hoje

2. Use locate para encontrar arquivos de configuração

3. Compare a velocidade entre find e locate



# Wildcards e Globbing: Dominando Padrões 🎯

## Wildcards Básicos

### Asterisco (*)

```BASH
# Exemplos básicos
ls *.txt               # Todos arquivos .txt
ls data*              # Tudo começando com "data"
ls *2023*             # Contém "2023" em qualquer lugar
ls /etc/*.d/          # Todos diretórios .d em /etc

# Combinações múltiplas
ls *.{jpg,png,gif}    # Todas as imagens
ls */*                # Arquivos em subdiretórios
ls **/*.sh           # Recursivo: todos .sh em qualquer nível
```

### Interrogação (?)

```BASH
# Substitui um caractere
ls file?.txt          # file1.txt, file2.txt, etc
ls ?.jpg              # Arquivos com um caractere
ls chapter_?.pdf      # chapter_1.pdf, chapter_2.pdf
```

## Globbing Avançado

### 

Conjuntos de Caracteres [...]

```BASH
# Intervalos
ls [a-z]*.txt         # Começa com minúscula
ls [A-Z]*.doc         # Começa com maiúscula
ls file[0-9].txt      # file seguido de um número

# Conjuntos específicos
ls [aeiou]*           # Começa com vogal
ls [!aeiou]*          # Não começa com vogal
ls [[:upper:]]*       # Começa com maiúscula
ls [[:digit:]]*       # Começa com número
```

### Extended Globbing

```BASH
# Ativar globbing estendido
shopt -s extglob

# Padrões
ls !(*.txt)           # Tudo exceto .txt
ls *(file|data)*      # Contém "file" ou "data"
ls +(*.jpg|*.png)     # Um ou mais arquivos de imagem
ls ?(test|prod).cfg   # test.cfg ou prod.cfg opcional
ls @(*.txt|*.doc)     # Exatamente um dos padrões
```

## Técnicas Avançadas

### Globbing com Find

```BASH
# Combinando com find
find . -name "*.txt" -o -name "*.doc"
find . -path "**/test/*.py"
find . -regex ".*\(test\|prod\).*\.cfg"
```

### Globbing em Scripts

```BASH
#!/bin/bash
# Configurações de globbing
shopt -s nullglob     # Arrays vazios para não-matches
shopt -s dotglob      # Inclui arquivos ocultos
shopt -s globstar     # Habilita **

# Processamento de arquivos
for file in **/*.{jpg,png,gif}; do
    echo "Processando: $file"
done
```

## Casos de Uso Comuns

### Organização de Arquivos

```BASH
# Mover por tipo
mv *{.jpg,.png} imagens/
mv *{.mp3,.wav} musicas/

# Backup seletivo
cp /etc/*.conf backup/
cp [A-Z]*.txt maiusculas/
```

### Processamento em Lote

```BASH
# Conversão de arquivos
for i in *.jpg; do
    convert "$i" "${i%.jpg}.png"
done

# Renomeação em massa
for f in [0-9]*.txt; do
    mv "$f" "arquivo_$f"
done
```

## Dicas e Truques

### Debug de Globbing

```BASH
# Ver expansões
set -x
ls *.txt
set +x

# Testar padrões
echo *.txt            # Ver o que será expandido
printf '%s\n' *       # Lista um por linha
```

### Segurança e Boas Práticas

```BASH
# Lidar com espaços
for file in "*.txt"; do  # Aspas importantes
    mv "$file" "novo_$file"
done

# Verificar existência
if compgen -G "*.txt" > /dev/null; then
    echo "Arquivos .txt encontrados"
fi
```

## Exercícios Práticos

### Básicos

1. Liste todos os arquivos PDF e DOCX

2. Encontre arquivos que começam com número

3. Mova todos os logs de 2023

4. Copie arquivos com vogais no nome

### Avançados

1. Use globbing estendido para organizar arquivos

2. Crie um script de backup seletivo

3. Implemente renomeação em massa com padrões

4. Desenvolva um sistema de classificação de arquivos

## Troubleshooting

### Problemas Comuns

```BASH
# Muito arquivos
# Use find em vez de globbing
find . -name "*.log" -exec rm {} \;

# Nomes complexos
# Use -print0 com xargs
find . -name "*.txt" -print0 | xargs -0 process
```

Tip:

"O domínio dos padrões de globbing é como ter superpoderes no terminal."



# Atalhos de Navegação

Note:

Domine os atalhos e técnicas para navegar rapidamente pelo sistema de arquivos.

## Atalhos do Terminal

### Movimentação no Comando

```BASH
# Movimentação básica
CTRL + A              # Início da linha
CTRL + E              # Fim da linha
ALT + B               # Palavra anterior
ALT + F               # Próxima palavra
CTRL + XX             # Alterna entre início e posição atual

# Edição
CTRL + W              # Apaga palavra anterior
CTRL + U              # Apaga do cursor até início
CTRL + K              # Apaga do cursor até fim
CTRL + Y              # Cola último texto apagado
ALT + D               # Apaga próxima palavra
```

### Histórico e Busca

```BASH
# Navegação no histórico
CTRL + R              # Busca reversa no histórico
CTRL + S              # Busca para frente no histórico
CTRL + G              # Cancela busca
!!                    # Repete último comando
!$                    # Último argumento do comando anterior
!*                    # Todos argumentos do comando anterior

# Modificadores de histórico
!!:p                  # Exibe último comando sem executar
!-n                   # Executa comando n posições atrás
!string               # Executa último comando começando com string
^string1^string2^     # Substitui string1 por string2 no último comando
```

## Atalhos de Diretório

### Jumping Directories

```BASH
# Atalhos básicos
cd -                  # Último diretório
cd                    # Home
cd ~user              # Home do usuário
pushd +n              # Rotaciona n posições na pilha
popd                  # Remove topo da pilha

# Bookmarks personalizados
export CDPATH=.:~/projetos:/var/www
alias cdp='cd ~/projetos'
alias cdd='cd ~/Downloads'
alias cdw='cd ~/workspace'
```

### Smart Directory Navigation

```BASH
# Função de jump inteligente
j() {
    local dir
    dir=$(find ~/projetos -type d -name "*$1*" | head -1)
    if [ -d "$dir" ]; then
        cd "$dir"
    else
        echo "Diretório não encontrado"
    fi
}

# Auto-jumping baseado em frequência
frecent() {
    local dir
    dir=$(sort -rn ~/.frecent | grep -i "$1" | head -1 | cut -f2)
    [ -d "$dir" ] && cd "$dir"
}
```

## Atalhos de Comando

### Command Line Editing

```BASH
# Edição rápida
fc                    # Edita último comando
CTRL + X + E          # Edita comando atual no editor
set -o vi             # Modo vi
set -o emacs          # Modo emacs (padrão)

# Substituições rápidas
^foo^bar              # Substitui primeira ocorrência
!!:gs/foo/bar/        # Substitui todas ocorrências
```

### Command Completion

```BASH
# Tab completion avançado
complete -W "$(echo `cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["`;)" ssh
complete -F _command sudo
```

## Customização Avançada

### Aliases Inteligentes

```BASH
# Aliases condicionais
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias ls='ls --color=auto'

# Aliases com funções
mcd() { mkdir -p "$1" && cd "$1"; }
cls() { cd "$1" && ls; }
```

### Keyboard Shortcuts

```BASH
# Bind customizado
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
bind '"\C-p": previous-history'
bind '"\C-n": next-history'
```

## Produtividade Máxima

### Workflow Optimization

```BASH
# Funções de produtividade
function mkcd() { mkdir -p "$@" && cd "$_"; }
function up() { cd $(printf "%0.s../" $(seq 1 $1)); }
function back() { cd "$OLDPWD"; }
```

### Task Automation

```BASH
# Scripts de automação
alias update='sudo apt update && sudo apt upgrade'
alias serve='python -m http.server'
alias ports='netstat -tulanp'
```

## Exercícios e Práticas

### Básicos

1. Configure aliases básicos

2. Pratique atalhos de movimentação

3. Use histórico eficientemente

4. Implemente bookmarks simples

### Avançados

1. Crie funções de navegação customizadas

2. Configure completion avançado

3. Implemente sistema de aliases dinâmicos

4. Desenvolva workflows automatizados

## Dicas de Performance

1. Memorize atalhos mais usados

2. Mantenha aliases organizados

3. Use completion sempre que possível

4. Automatize tarefas repetitivas

5. Mantenha histórico limpo e útil

Tip:

"A velocidade vem da prática, mas os atalhos são o caminho mais rápido para lá."



# Automação de Navegação

Note:

Aprenda a criar scripts e funções para automatizar tarefas de navegação no sistema de arquivos.

## Scripts de Navegação

### Navegador Inteligente

```BASH
#!/bin/bash
# smart_nav.sh
# Navegador inteligente com histórico e frequência

# Configuração
HISTORY_FILE="$HOME/.nav_history"
BOOKMARKS_FILE="$HOME/.nav_bookmarks"
touch "$HISTORY_FILE" "$BOOKMARKS_FILE"

# Função principal de navegação
smart_nav() {
    local target="$1"
    
    # Verifica bookmarks primeiro
    if grep -q "^$target:" "$BOOKMARKS_FILE"; then
        cd "$(grep "^$target:" "$BOOKMARKS_FILE" | cut -d: -f2)"
        return
    fi
    
    # Busca no histórico
    local dir=$(grep -i "$target" "$HISTORY_FILE" | sort -r | head -1)
    if [ -n "$dir" ] && [ -d "$dir" ]; then
        cd "$dir"
        return
    fi
    
    # Busca fuzzy em diretórios comuns
    local found=$(find ~/projetos ~/documentos -type d -iname "*$target*" 2>/dev/null | head -1)
    if [ -n "$found" ]; then
        cd "$found"
        return
    fi
    
    echo "Destino não encontrado: $target"
}
```

### Sistema de Bookmarks

```BASH
# Gerenciador de bookmarks
bookmark() {
    case "$1" in
        add)
            echo "$2:$(pwd)" >> "$BOOKMARKS_FILE"
            echo "Bookmark '$2' adicionado"
            ;;
        remove)
            sed -i "/^$2:/d" "$BOOKMARKS_FILE"
            echo "Bookmark '$2' removido"
            ;;
        list)
            cat "$BOOKMARKS_FILE"
            ;;
        *)
            echo "Uso: bookmark [add|remove|list] [nome]"
            ;;
    esac
}
```

## Automação de Workspace

### Projeto Automático

```BASH
# Configuração de workspace automática
setup_workspace() {
    local project="$1"
    local template="$2"
    
    # Cria estrutura base
    mkdir -p "$project"/{src,docs,tests,resources}
    
    # Aplica template se especificado
    if [ -n "$template" ] && [ -d "$HOME/.templates/$template" ]; then
        cp -r "$HOME/.templates/$template"/* "$project/"
    fi
    
    # Inicializa git
    cd "$project"
    git init
    
    # Cria arquivo de configuração
    cat > .workspace-config <<EOF
PROJECT_NAME=$project
CREATED_AT=$(date +%Y-%m-%d)
TEMPLATE=$template
EOF
    
    echo "Workspace $project configurado com sucesso!"
}
```

### Monitor de Diretório

```BASH
# Monitora mudanças e executa ações
watch_dir() {
    local dir="${1:-.}"
    local action="$2"
    
    inotifywait -m -e create,modify,delete "$dir" |
    while read -r directory events filename; do
        echo "Evento: $events em $filename"
        if [ -n "$action" ]; then
            eval "$action \"$filename\""
        fi
    done
}
```

## Automação de Tarefas

### Sincronização Automática

```BASH
# Sincroniza diretórios automaticamente
auto_sync() {
    local source="$1"
    local target="$2"
    local interval="${3:-300}" # 5 minutos padrão
    
    while true; do
        rsync -av --delete "$source/" "$target/"
        echo "Sincronizado em $(date)"
        sleep "$interval"
    done
}
```

### Limpeza Automática

```BASH
# Mantém diretórios organizados
auto_clean() {
    local dir="${1:-.}"
    local days="${2:-7}"
    
    # Remove arquivos antigos
    find "$dir" -type f -mtime +"$days" -delete
    
    # Organiza por extensão
    for file in "$dir"/*.*; do
        if [ -f "$file" ]; then
            ext="${file##*.}"
            mkdir -p "$dir/$ext"
            mv "$file" "$dir/$ext/"
        fi
    done
}
```

## Integração com Sistema

### Auto-mounting

```BASH
# Monta dispositivos automaticamente
auto_mount() {
    local device="$1"
    local mountpoint="$2"
    
    if [ ! -d "$mountpoint" ]; then
        sudo mkdir -p "$mountpoint"
    fi
    
    sudo mount "$device" "$mountpoint"
    echo "Montado $device em $mountpoint"
}
```

### Backup Automático

```BASH
# Sistema de backup incremental
auto_backup() {
    local source="$1"
    local dest="$2"
    local date=$(date +%Y%m%d)
    
    # Cria backup incremental
    rsync -av --link-dest="../latest" "$source/" "$dest/$date/"
    
    # Atualiza link do último backup
    ln -nsf "$date" "$dest/latest"
}
```

## Exemplos Práticos

### Workflow Desenvolvimento

```BASH
# Configura ambiente de desenvolvimento
dev_env() {
    local project="$1"
    
    # Terminal 1: Editor
    tmux new-session -d -s "$project"
    tmux send-keys "cd $project && vim" C-m
    
    # Terminal 2: Servidor
    tmux split-window -h
    tmux send-keys "cd $project && npm start" C-m
    
    # Terminal 3: Git
    tmux split-window -v
    tmux send-keys "cd $project && git status" C-m
    
    # Anexa à sessão
    tmux attach-session -t "$project"
}
```

### Monitor de Recursos

```BASH
# Monitora recursos do sistema
monitor_resources() {
    while true; do
        clear
        echo "=== Sistema ==="
        date
        echo "=== CPU ==="
        top -bn1 | head -n 3
        echo "=== Memória ==="
        free -h
        echo "=== Disco ==="
        df -h /
        sleep 5
    done
}
```

## Dicas e Boas Práticas

1. Mantenha logs de todas automações

2. Implemente tratamento de erros

3. Use variáveis de configuração

4. Documente todas as funções

5. Faça backup antes de automações críticas

Tip:

"Automatize tudo que fizer mais de duas vezes."



# Resolução de Problemas de Navegação

Note:

Aprenda a identificar e resolver problemas comuns relacionados à navegação no sistema.

## Problemas Comuns

### Permissões

```BASH
# Verificar permissões
ls -la                # Lista detalhada com permissões
namei -l /path/to/dir # Mostra permissões do caminho completo

# Corrigir permissões
chmod -R u+rwx dir    # Recursivamente adiciona permissões
chown -R user:group dir # Muda proprietário recursivamente
```

### Caminhos Quebrados

```BASH
# Verificar links simbólicos
find . -type l -ls    # Lista todos links
find . -xtype l       # Encontra links quebrados

# Corrigir links
ln -sf target link   # Força criação/atualização do link
realpath arquivo     # Mostra caminho real
```

## Ferramentas de Diagnóstico

### Análise de Sistema

```BASH
# Verificação de disco
df -h                 # Espaço em disco
du -sh *             # Uso por diretório
ncdu                 # Navegador de uso de disco

# Monitoramento
iotop                # Monitoramento de I/O
lsof                 # Arquivos abertos
fuser -m /path       # Processos usando diretório
```

### Debug de Navegação

```BASH
# Trace de comandos
set -x               # Ativa debug
pwd -P               # Mostra caminho físico
type cd              # Verifica definição do comando
echo $PATH           # Mostra variável PATH
```

## Recuperação

### Backup Rápido

```BASH
# Backup de segurança
cp -a dir dir.bak    # Copia preservando atributos
tar czf backup.tgz dir # Compacta diretório
rsync -av --delete source/ dest/ # Sincroniza com backup
```

### Restauração

```BASH
# Recuperar arquivos
cp -a dir.bak/* dir/ # Restaura do backup
tar xzf backup.tgz   # Extrai backup
git checkout -- file # Restaura do git
```

## Prevenção

### Verificações de Segurança

```BASH
# Checklist de segurança
function check_dir() {
    local dir="$1"
    echo "Verificando $dir..."
    
    # Permissões
    ls -ld "$dir"
    
    # Links simbólicos
    find "$dir" -type l -ls
    
    # Espaço
    du -sh "$dir"
    
    # Processos
    lsof +D "$dir"
}
```

### Monitoramento Proativo

```BASH
# Monitor de mudanças
inotifywait -m -r -e modify,create,delete /path/to/watch

# Logger de ações
function log_cd() {
    echo "$(date): cd $PWD" >> ~/.cd_history
}
trap 'log_cd' DEBUG
```

## Soluções Avançadas

### Recuperação de Diretório

```BASH
# Script de recuperação
recover_dir() {
    local dir="$1"
    
    # Verifica backup
    if [ -d "${dir}.bak" ]; then
        echo "Restaurando de backup..."
        rsync -av "${dir}.bak/" "$dir/"
        return
    fi
    
    # Tenta reconstruir
    mkdir -p "$dir"
    find . -name "$(basename "$dir")*" -type f -exec cp {} "$dir/" \;
}
```

### Limpeza de Sistema

```BASH
# Limpeza segura
safe_clean() {
    # Remove temporários
    find /tmp -type f -atime +7 -delete
    
    # Remove logs antigos
    find /var/log -type f -name "*.log.*" -mtime +30 -delete
    
    # Limpa caches
    rm -rf ~/.cache/*
}
```

## Casos Especiais

### Sistemas de Arquivos Especiais

```BASH
# Montagem NFS
mount -t nfs server:/share /mnt/nfs

# SSHFS
sshfs user@remote:/path /mnt/remote

# Verificação
mount | grep "type"
```

### Problemas de Rede

```BASH
# Debug de rede
ping -c 4 server     # Teste básico
traceroute server    # Rota até servidor
mtr server          # Monitoramento contínuo
```

## Checklist de Troubleshooting

1. Verificar Permissões

```BASH
ls -la
whoami
groups
```

1. Verificar Espaço

```BASH
df -h
du -sh *
```

1. Verificar Processos

```BASH
ps aux | grep dir
lsof +D /path
```

1. Verificar Logs

```BASH
tail -f /var/log/syslog
journalctl -f
```

## Dicas de Manutenção

### Manutenção Regular

```BASH
# Script de manutenção
maintenance() {
    echo "Iniciando manutenção..."
    
    # Verifica sistema de arquivos
    sudo fsck -f /dev/sda1
    
    # Limpa caches
    sudo sync && sudo sysctl -w vm.drop_caches=3
    
    # Otimiza banco de dados
    sudo updatedb
    
    echo "Manutenção concluída!"
}
```

### Monitoramento Contínuo

```BASH
# Monitor de saúde
health_check() {
    while true; do
        date
        df -h
        free -h
        uptime
        sleep 300
    done
}
```

Tip:

"Problemas são oportunidades de aprendizado disfarçadas."



# Operações com Arquivos

Note:

Encontre os exemplos práticos em `code/module2/file-ops/file_operations.sh`. Cada operação está documentada e pronta para uso.

```
INICIANDO OPERAÇÕES COM ARQUIVOS...
==================================
STATUS: SISTEMA DE ARQUIVOS ATIVO
PODER: MANIPULAÇÃO TOTAL
==================================
```

## Visão Geral

Este módulo abrange um conjunto completo de operações com arquivos, incluindo:

* Operações básicas (criar, copiar, mover, remover)

* Operações avançadas (sincronização, clonagem, links)

* Gerenciamento de permissões

* Compactação e arquivamento

* Links simbólicos e hardlinks

* Monitoramento de arquivos

* Operações em lote

## Tópicos do Módulo

### 

1. [Operações Básicas](basic-file-ops.html)

* Criação e manipulação de arquivos

* Cópia e movimentação

* Remoção segura

* Redirecionamento de conteúdo

### 

2. [Operações Avançadas](advanced-file-ops.html)

* Sincronização com rsync

* Clonagem com dd

* Operações em lote

* Processamento paralelo

### 

3. [Permissões de Arquivos](file-permissions.html)

* Permissões básicas

* ACLs avançadas

* SUID, SGID e Sticky Bit

* Atributos especiais

### 

4. [Compactação e Arquivamento](archive-compression.html)

* tar, gzip, bzip2

* Compactação avançada

* Arquivamento incremental

* Backup e restauração

### 

5. [Links Simbólicos e Hardlinks](symlinks-hardlinks.html)

* Criação de links

* Gerenciamento de links

* Boas práticas

* Troubleshooting

### 

6. [Monitoramento de Arquivos](file-monitoring.html)

* inotify e watchdog

* Logs de acesso

* Auditoria de mudanças

* Alertas automáticos

### 

7. [Operações em Lote](batch-operations.html)

* find e xargs

* Processamento paralelo

* Automação de tarefas

* Scripts de lote

### 

8. [Troubleshooting](file-ops-troubleshooting.html)

* Problemas comuns

* Diagnóstico

* Recuperação

* Melhores práticas

## Ferramentas Essenciais

### 🛠️ Comandos Básicos

```BASH
# Criação e Manipulação
touch arquivo.txt              # Cria arquivo
cp origem.txt destino.txt     # Copia arquivo
mv antigo.txt novo.txt        # Move/renomeia
rm arquivo.txt                # Remove arquivo

# Diretórios
mkdir -p dir1/dir2            # Cria diretórios
rmdir diretorio              # Remove diretório vazio
rm -rf diretorio            # Remove recursivamente
```

### 🚀 Comandos Avançados

```BASH
# Sincronização
rsync -avz fonte/ destino/   # Sincroniza diretórios
rsync -avz --delete src/ dst/ # Sincroniza e limpa

# Clonagem
dd if=/dev/sda of=disk.img   # Clona dispositivo
dd if=/dev/zero of=file bs=1M count=100  # Cria arquivo

# Links
ln -s arquivo link           # Link simbólico
ln arquivo hardlink         # Hard link
```

## Dicas de Poder

### ⚡ Operações Eficientes

```BASH
# Pipeline de processamento
find . -type f -name "*.log" | \
  xargs grep "ERROR" | \
  sort | uniq -c | \
  sort -nr

# Processamento paralelo
find . -name "*.jpg" | \
  parallel convert {} {.}.png
```

### 🔒 Segurança

```BASH
# Remoção segura
shred -u arquivo.txt         # Sobrescreve e remove
rm -P arquivo.txt           # Sobrescreve 3 vezes

# Backup seguro
tar czf - /dados | gpg -c > backup.tar.gz.gpg
```

## Exercícios Práticos

### 🎯 Missão 1: Gerenciamento Básico

```BASH
# Crie uma estrutura de trabalho
mkdir -p projeto/{src,docs,tests}
touch projeto/src/{main,util}.sh
cp projeto/src/main.sh projeto/docs/
mv projeto/src/util.sh projeto/tests/
```

### 🎯 Missão 2: Operações Avançadas

```BASH
# Implemente um sistema de backup
rsync -avz --progress \
  --exclude '*.tmp' \
  --exclude '*.log' \
  fonte/ destino/
```

### 🎯 Missão 3: Automação

```BASH
# Crie um script de processamento
find . -type f -name "*.jpg" | \
  while read file; do
    convert "$file" -resize 50% "${file%.*}_small.jpg"
  done
```

## Próximos Passos

Depois de dominar as operações com arquivos:

1. [Scripts e Automação](scripting.html)

2. [Administração do Sistema](system-admin.html)

3. [Redes e Conectividade](network-admin.html)

Tip:

"O verdadeiro poder vem da capacidade de manipular arquivos com precisão e eficiência."

```
MÓDULO CONCLUÍDO
[████████████████] 100%
STATUS: OPERACIONAL
PODER: MAXIMIZADO
```



# Operações Básicas com Arquivos 📄

Note:

Experimente o script interativo em `code/module2/file-ops/basic_ops.sh` para praticar estas operações.

```
INICIANDO OPERAÇÕES BÁSICAS...
=============================
STATUS: PRONTO
NÍVEL: FUNDAMENTAL
OPERAÇÕES: CRIAR, COPIAR, MOVER, REMOVER
```

## Criação de Arquivos

### Touch - Criando Arquivos Vazios

```BASH
touch arquivo.txt           # Cria arquivo vazio
touch -t 202312251200 arq  # Define data/hora específica
touch {1..5}.txt          # Cria múltiplos arquivos
```

### Redirecionamento - Criando com Conteúdo

```BASH
echo "conteúdo" > arquivo.txt    # Cria/sobrescreve
echo "mais texto" >> arquivo.txt # Adiciona ao final
cat > arquivo.txt << EOF         # Múltiplas linhas
linha 1
linha 2
EOF
```

## Cópia de Arquivos

### CP - Comando de Cópia

```BASH
cp origem.txt destino.txt        # Cópia básica
cp -i arquivo.txt backup/        # Modo interativo
cp -r diretorio/ backup/        # Cópia recursiva
cp -p arquivo.txt destino.txt   # Preserva atributos
```

### Opções Úteis do CP

* `-v`: Modo verboso

* `-u`: Atualiza apenas se origem for mais nova

* `-l`: Cria hard links em vez de copiar

* `-s`: Cria symbolic links em vez de copiar

## Movimentação de Arquivos

### MV - Movendo e Renomeando

```BASH
mv arquivo.txt novo.txt          # Renomeia
mv arquivo.txt /tmp/            # Move
mv -i *.txt destino/           # Move múltiplos
mv -n origem destino           # Não sobrescreve
```

### Boas Práticas

```BASH
mv -b arquivo.txt destino/     # Cria backup
mv -- -arquivo.txt destino/    # Move arquivo com '-'
```

## Remoção de Arquivos

### RM - Removendo Arquivos

```BASH
rm arquivo.txt                  # Remove arquivo
rm -i arquivo.txt              # Modo interativo
rm -r diretorio/              # Remove recursivamente
rm -f arquivo.txt             # Força remoção
```

### Dicas de Segurança

```BASH
# Alias seguro para rm
alias rm='rm -i'

# Função de lixeira
trash() {
    local dest="$HOME/.trash"
    mkdir -p "$dest"
    mv "$@" "$dest/"
}
```

## Exercícios Práticos

### 🎯 Missão 1: Gerenciamento Básico

```BASH
# Crie uma estrutura de trabalho
mkdir -p projeto/{src,docs,tests}
touch projeto/src/{main,util}.sh
cp projeto/src/main.sh projeto/docs/
mv projeto/src/util.sh projeto/tests/
```

### 🎯 Missão 2: Backup Seguro

```BASH
# Crie um sistema de backup
timestamp=$(date +%Y%m%d_%H%M%S)
cp -r projeto/ backup_${timestamp}/
```

## Troubleshooting

### Problemas Comuns

* Permissão negada: Verifique permissões com `ls -l`

* Arquivo não encontrado: Confirme o caminho com `pwd` e `ls`

* Disco cheio: Verifique espaço com `df -h`

### Verificações de Segurança

```BASH
# Antes de operações destrutivas
ls -l arquivo.txt          # Verificar existência
du -sh diretorio/         # Verificar tamanho
file arquivo.txt          # Verificar tipo
```

## Próximos Passos

Agora que você domina as operações básicas:

1. [Operações Avançadas](advanced-file-ops.html)

2. [Permissões de Arquivos](file-permissions.html)

3. [Compactação e Arquivamento](archive-compression.html)

Tip:

"A habilidade de manipular arquivos com precisão é o fundamento de todo administrador de sistemas."



# Operações Avançadas com Arquivos 🚀

Warning:

Este módulo requer conhecimento das operações básicas com arquivos.

```
OPERAÇÕES AVANÇADAS
==================
STATUS: POWER USER
NÍVEL: AVANÇADO
PODER: MÁXIMO
```

## Sincronização com Rsync

### Sincronização Básica

```BASH
# Sincronização local
rsync -av fonte/ destino/           # Sincroniza diretórios
rsync -avz --delete fonte/ destino/ # Sincroniza e remove extras
rsync -avP arquivo.iso backup/      # Mostra progresso

# Sincronização remota
rsync -ave ssh fonte/ user@host:/destino/
rsync -avz --exclude '*.tmp' fonte/ destino/
```

## Operações com DD

### Clonagem e Backup

```BASH
# Backup de dispositivo
dd if=/dev/sda of=disk.img bs=4M status=progress
dd if=/dev/zero of=/dev/sdb bs=4M    # Limpa dispositivo

# Conversão e cópia
dd if=input.iso of=/dev/usb bs=4M conv=fdatasync
dd if=/dev/urandom of=arquivo bs=1M count=100
```

## Find Avançado

### Busca e Execução

```BASH
# Busca com execução
find . -type f -name "*.log" -exec grep "ERROR" {} \;
find . -mtime +30 -delete           # Remove arquivos antigos
find . -size +100M -exec ls -lh {} \;

# Busca com confirmação
find . -name "*.tmp" -ok rm {} \;
```

### Expressões Complexas

```BASH
# Combinando condições
find . \( -name "*.jpg" -o -name "*.png" \) -size +1M
find . -type f -not -name "*.txt"
find . -perm 644 -user admin
```

## Xargs Power

### Processamento em Lote

```BASH
# Processamento paralelo
find . -name "*.jpg" | xargs -P4 -I{} convert {} {}.png
find . -type f | xargs -P8 md5sum > checksums.txt

# Operações complexas
find . -name "*.bak" | xargs -I{} bash -c 'mv "{}" "$(dirname "{}")/$(date +%F)_$(basename "{}")"'
```

## Monitoramento em Tempo Real

### Inotify Watch

```BASH
# Monitoramento de diretório
inotifywait -m -r -e modify,create,delete /path/to/watch
inotifywait -m /var/log/auth.log | while read line; do
    echo "[$(date)] $line" >> /var/log/changes.log
done
```

## Scripts Avançados

### Script de Backup Incremental

```BASH
#!/bin/bash
# backup_incremental.sh

BACKUP_DIR="/backup"
SOURCE_DIR="/dados"
DATE=$(date +%Y%m%d)

# Cria backup incremental usando hard links
rsync -av --link-dest="../latest" \
    "$SOURCE_DIR/" "$BACKUP_DIR/$DATE/"

# Atualiza link do último backup
ln -nsf "$DATE" "$BACKUP_DIR/latest"
```

### Script de Processamento em Lote

```BASH
#!/bin/bash
# batch_process.sh

process_file() {
    local file="$1"
    local ext="${file##*.}"
    local base="${file%.*}"
    
    case "$ext" in
        jpg|jpeg) convert "$file" -resize 50% "${base}_small.${ext}" ;;
        txt) gzip "$file" ;;
        log) bzip2 "$file" ;;
    esac
}

export -f process_file
find . -type f | parallel process_file
```

## Exercícios Avançados

### 🎯 Missão 1: Backup Inteligente

```BASH
# Crie um sistema de backup que:
# 1. Use rsync para sincronização
# 2. Mantenha versões incrementais
# 3. Comprima arquivos antigos
# 4. Gere relatório de mudanças
```

### 🎯 Missão 2: Processamento Massivo

```BASH
# Desenvolva um script que:
# 1. Encontre arquivos grandes (+100MB)
# 2. Processe em paralelo
# 3. Gere checksums
# 4. Monitore mudanças
```

## Troubleshooting Avançado

### Diagnóstico

* Use `strace` para debugar operações de arquivo

* Monitore I/O com `iotop`

* Verifique limites do sistema com `ulimit -a`

### Recuperação

```BASH
# Recuperação de dados
dd if=/dev/sda of=backup.img conv=noerror,sync
testdisk backup.img           # Analisa estrutura
photorec backup.img          # Recupera arquivos
```

## Próximos Passos

1. [Permissões Avançadas](file-permissions.html)

2. [Sistemas de Arquivos](null)

3. [Otimização de I/O](null)

Tip:

"Com grande poder vem grande responsabilidade. Use estas ferramentas com sabedoria."



# Permissões de Arquivos 🔒

Warning:

Gerenciamento avançado de permissões e controle de acesso.

```
CONTROLE DE ACESSO
=================
STATUS: CRÍTICO
NÍVEL: AVANÇADO
SEGURANÇA: MÁXIMA
```

## Permissões Básicas

### Estrutura de Permissões

```BASH
# Formato: [tipo][user][group][others]
ls -l arquivo.txt
# -rw-r--r-- 1 user group 0 Jan 1 12:00 arquivo.txt
#  ^ ^^^ ^^^ ^^^
#  | |   |   |
#  | |   |   +-> outros (r--)
#  | |   +-> grupo (r--)
#  | +-> usuário (rw-)
#  +-> tipo (-)
```

### Modificando Permissões

```BASH
# Modo Octal
chmod 644 arquivo.txt    # rw-r--r--
chmod 755 script.sh      # rwxr-xr-x
chmod 600 id_rsa        # rw-------

# Modo Simbólico
chmod u+x script.sh      # Adiciona execução para usuário
chmod g-w arquivo.txt    # Remove escrita do grupo
chmod o= arquivo.txt     # Remove todas permissões de outros
```

## Permissões Especiais

### SUID, SGID e Sticky Bit

```BASH
# SUID - Executa como proprietário
chmod 4755 programa     # -rwsr-xr-x
chmod u+s programa      # Modo simbólico

# SGID - Executa como grupo
chmod 2755 diretorio    # -rwxr-sr-x
chmod g+s diretorio     # Modo simbólico

# Sticky Bit - Proteção de deleção
chmod 1777 /tmp         # -rwxrwxrwt
chmod +t diretorio      # Modo simbólico
```

## ACLs Avançadas

### Gerenciamento de ACLs

```BASH
# Listando ACLs
getfacl arquivo.txt

# Configurando ACLs
setfacl -m u:usuario:rw arquivo.txt    # Permissão para usuário
setfacl -m g:grupo:rx arquivo.txt      # Permissão para grupo
setfacl -x u:usuario arquivo.txt       # Remove ACL específica
setfacl -b arquivo.txt                 # Remove todas ACLs
```

### ACLs Padrão

```BASH
# ACLs para novos arquivos
setfacl -d -m u:usuario:rx diretorio/
setfacl -d -m g:grupo:rwx diretorio/
```

## Atributos Estendidos

### Gerenciamento de Atributos

```BASH
# Listando atributos
lsattr arquivo.txt

# Configurando atributos
chattr +i arquivo.txt    # Imutável
chattr +a log.txt       # Append-only
chattr +s arquivo.txt   # Deleção segura
```

## Propriedade e Grupos

### Mudança de Proprietário

```BASH
# Mudando proprietário
chown usuario:grupo arquivo.txt
chown -R usuario:grupo diretorio/

# Mudando apenas grupo
chgrp grupo arquivo.txt
chgrp -R grupo diretorio/
```

## Scripts de Segurança

### Auditoria de Permissões

```BASH
#!/bin/bash
# audit_permissions.sh

check_permissions() {
    find "$1" -type f -perm /4000 -print | while read file; do
        echo "SUID encontrado: $file"
        ls -l "$file"
    done
}

check_world_writable() {
    find "$1" -type f -perm -002 -print | while read file; do
        echo "Arquivo gravável globalmente: $file"
        ls -l "$file"
    done
}

# Uso
check_permissions /usr/bin
check_world_writable /home
```

### Correção Automática

```BASH
#!/bin/bash
# fix_permissions.sh

fix_permissions() {
    # Arquivos sensíveis
    chmod 600 ~/.ssh/id_rsa
    chmod 644 ~/.ssh/id_rsa.pub
    
    # Diretórios de configuração
    chmod 700 ~/.ssh
    chmod 750 ~/scripts
    
    # Scripts executáveis
    find ~/scripts -type f -name "*.sh" -exec chmod u+x {} \;
}
```

## Exercícios Avançados

### 🎯 Missão 1: Hardening de Permissões

```BASH
# Implemente um sistema que:
# 1. Identifique permissões inseguras
# 2. Corrija automaticamente
# 3. Gere relatório de mudanças
# 4. Mantenha log de auditoria
```

### 🎯 Missão 2: ACLs Complexas

```BASH
# Crie uma estrutura que:
# 1. Use ACLs para controle fino
# 2. Implemente herança de permissões
# 3. Gerencie múltiplos grupos
# 4. Mantenha backup das ACLs
```

## Troubleshooting

### Problemas Comuns

* Permissão negada: Verifique com `ls -la` e `getfacl`

* SUID não funciona: Verifique sistema de arquivos (noexec)

* ACLs não aplicam: Verifique suporte do sistema de arquivos

### Diagnóstico

```BASH
# Verificação de problemas
namei -l /path/to/file    # Mostra permissões do caminho
strace -e trace=access comando  # Debug de acesso
ausearch -f /path/to/file # Busca em logs de auditoria
```

## Próximos Passos

1. [SELinux e AppArmor](null)

2. [Criptografia de Arquivos](null)

3. [Auditoria de Sistema](null)

Tip:

"Segurança não é um produto, é um processo. Mantenha suas permissões sempre atualizadas."



# Arquivamento e Compressão

Note:

Domine as técnicas de compactação e gerenciamento de arquivos para otimizar o armazenamento.

## Ferramentas de Compactação

### 🔧 Gzip

```BASH
# Compactação básica
gzip arquivo.txt            # Compacta para arquivo.txt.gz
gunzip arquivo.txt.gz       # Descompacta
gzip -9 arquivo.txt        # Máxima compressão
gzip -l arquivo.txt.gz     # Lista informações
```

### 🔧 Bzip2

```BASH
# Compactação com bzip2
bzip2 arquivo.txt          # Compacta para arquivo.txt.bz2
bunzip2 arquivo.txt.bz2    # Descompacta
bzip2 -9 arquivo.txt      # Máxima compressão
bzcat arquivo.txt.bz2     # Visualiza sem descompactar
```

### 🔧 XZ

```BASH
# Compactação com xz
xz arquivo.txt            # Compacta para arquivo.txt.xz
unxz arquivo.txt.xz       # Descompacta
xz -9 arquivo.txt        # Máxima compressão
xzcat arquivo.txt.xz     # Visualiza sem descompactar
```

## Arquivamento com Tar

### 📚 Operações Básicas

```BASH
# Criar arquivo tar
tar -cf arquivo.tar dir/     # Cria arquivo tar
tar -czf arquivo.tar.gz dir/ # Cria tar.gz
tar -cjf arquivo.tar.bz2 dir/ # Cria tar.bz2
tar -cJf arquivo.tar.xz dir/  # Cria tar.xz

# Extrair arquivos
tar -xf arquivo.tar         # Extrai tar
tar -xzf arquivo.tar.gz     # Extrai tar.gz
tar -xjf arquivo.tar.bz2    # Extrai tar.bz2
tar -xJf arquivo.tar.xz     # Extrai tar.xz
```

### 📚 Operações Avançadas

```BASH
# Visualizar conteúdo
tar -tvf arquivo.tar        # Lista conteúdo
tar -ztvf arquivo.tar.gz    # Lista conteúdo gz

# Adicionar/Atualizar
tar -rf arquivo.tar novo/   # Adiciona ao tar
tar -uf arquivo.tar alterado/ # Atualiza arquivos
```

## Backup e Arquivamento

### 💾 Backup Incremental

```BASH
# Backup com data
DATE=$(date +%Y%m%d)
tar -czf backup_$DATE.tar.gz \
    --listed-incremental=backup.snar \
    /dados/

# Restauração incremental
tar -xzf backup_$DATE.tar.gz \
    --listed-incremental=/dev/null
```

### 💾 Backup com Exclusões

```BASH
# Excluir padrões
tar -czf backup.tar.gz \
    --exclude='*.tmp' \
    --exclude='*.log' \
    --exclude-vcs \
    /dados/
```

## Compactação Avançada

### 🚀 Compactação Paralela

```BASH
# Usando pigz (gzip paralelo)
tar -cf - dir/ | pigz -9 > arquivo.tar.gz

# Usando pbzip2
tar -cf - dir/ | pbzip2 -9 > arquivo.tar.bz2
```

### 🚀 Compactação Seletiva

```BASH
# Compactar por tipo
find . -name "*.log" -exec gzip {} \;

# Compactar arquivos antigos
find . -type f -mtime +30 -exec gzip {} \;
```

## Técnicas de Otimização

### ⚡ Compactação Eficiente

```BASH
# Melhor razão de compressão
for file in *.txt; do
    gzip -9 "$file" &  # Paralelo
done
wait

# Comparação de métodos
for file in dados.*; do
    size=$(stat -f %z "$file")
    echo "$file: $size bytes"
done
```

### ⚡ Arquivamento Inteligente

```BASH
# Backup com verificação
tar -czf backup.tar.gz dir/ && \
md5sum backup.tar.gz > backup.md5

# Verificar integridade
md5sum -c backup.md5
```

## Exercícios Práticos

### 🎯 Missão 1: Backup Automatizado

```BASH
#!/bin/bash
# backup_system.sh

BACKUP_DIR="/backup"
SOURCE_DIR="/dados"
DATE=$(date +%Y%m%d_%H%M%S)

# Criar backup compactado
tar -czf "$BACKUP_DIR/backup_$DATE.tar.gz" \
    --exclude='*.tmp' \
    --exclude='*.log' \
    "$SOURCE_DIR"

# Manter apenas últimos 5 backups
ls -t "$BACKUP_DIR"/backup_*.tar.gz | \
    tail -n +6 | xargs rm -f
```

### 🎯 Missão 2: Compactação em Lote

```BASH
#!/bin/bash
# compress_logs.sh

# Compacta logs antigos
find /var/log -type f -name "*.log" \
    -mtime +7 \
    -exec gzip {} \;

# Remove logs muito antigos
find /var/log -type f -name "*.gz" \
    -mtime +30 \
    -delete
```

## Troubleshooting

### 🔧 Problemas Comuns

* Espaço insuficiente: Use `df -h` para verificar

* Arquivos corrompidos: Use `gzip -t` para testar

* Permissões: Verifique com `ls -l`

* Performance: Use versões paralelas dos compactadores

Tip:

"A arte da compactação está no equilíbrio entre tamanho e velocidade."

```
COMPACTAÇÃO CONCLUÍDA
[████████████████] 100%
RAZÃO: OTIMIZADA
ESPAÇO: ECONOMIZADO
```



# Links Simbólicos e Hardlinks: Conectando os Pontos 🔗

## Conceitos Básicos

### Links Simbólicos (Soft Links)

```BASH
# Criação básica
ln -s arquivo.txt link_simbolico    # Cria link simbólico
ln -s /caminho/completo/arquivo link # Com caminho absoluto
ln -s ../arquivo link              # Com caminho relativo

# Opções úteis
ln -sf arquivo link               # Força criação
ln -snf arquivo link             # Força, não segue links
```

### Hardlinks

```BASH
# Criação básica
ln arquivo.txt hardlink           # Cria hardlink
ln arquivo1 arquivo2 dir/        # Múltiplos hardlinks
ln -f origem destino            # Força criação
```

## Gerenciamento de Links

### 🔍 Identificação

```BASH
# Verificação de links
ls -l                    # Lista com detalhes
ls -la                   # Inclui ocultos
readlink link           # Mostra destino do symlink
stat arquivo           # Informações detalhadas

# Contagem de hardlinks
ls -l arquivo           # Mostra número de links
find . -samefile arquivo # Encontra hardlinks
```

### 🔧 Manutenção

```BASH
# Atualização de links
ln -sf novo_destino link    # Atualiza symlink
mv link novo_nome          # Renomeia link
rm link                   # Remove link

# Verificação de integridade
find . -type l -! -exec test -e {} \; -print  # Links quebrados
find . -xtype l           # Alternativa para links quebrados
```

## Boas Práticas

### ✅ Recomendações

```BASH
# Links simbólicos
ln -s "$(readlink -f arquivo)" link  # Usa caminho absoluto
ln -s "$(pwd)/arquivo" link         # Alternativa explícita

# Hardlinks
ln arquivo link && chmod --reference=arquivo link  # Preserva permissões
```

### ⚠️ Cuidados

```BASH
# Evite loops
ln -s link1 link2    # Pode criar loop
ln -s . loop        # Loop direto

# Backup antes de modificar
cp -P link link.bak  # Preserva links
```

## Scripts Úteis

### 🤖 Gerenciador de Links

```BASH
#!/bin/bash
# link_manager.sh

check_links() {
    local dir="${1:-.}"
    echo "Verificando links em $dir..."
    
    # Links quebrados
    find "$dir" -type l -! -exec test -e {} \; -print
    
    # Hardlinks múltiplos
    find "$dir" -type f -links +1 -print
}

update_links() {
    local old_path="$1"
    local new_path="$2"
    
    find . -lname "*${old_path}*" -exec ln -sf \
        "$(readlink {} | sed "s|${old_path}|${new_path}|")" {} \;
}
```

### 🔄 Sincronização de Links

```BASH
#!/bin/bash
# sync_links.sh

sync_directory() {
    local src="$1"
    local dst="$2"
    
    # Copia preservando links
    cp -a "$src/" "$dst/"
    
    # Atualiza links relativos
    cd "$dst"
    find . -type l -exec bash -c '
        link=$(readlink "$1")
        if [[ $link != /* ]]; then
            ln -sf "$link" "$1"
        fi
    ' _ {} \;
}
```

## Exercícios Práticos

### 🎯 Missão 1: Sistema de Links

```BASH
# Crie uma estrutura de links
mkdir -p projeto/{bin,lib,config}
touch projeto/lib/biblioteca.so.1
ln -s biblioteca.so.1 projeto/lib/biblioteca.so
ln projeto/lib/biblioteca.so.1 projeto/bin/
```

### 🎯 Missão 2: Migração de Links

```BASH
# Migre links entre diretórios
old_dir="/antigo/caminho"
new_dir="/novo/caminho"
find . -type l -lname "$old_dir/*" -exec \
    ln -sf "$(readlink {} | sed "s|$old_dir|$new_dir|")" {} \;
```

## Troubleshooting

### 🔧 Problemas Comuns

* Link quebrado: Use `readlink` para verificar destino

* Permissão negada: Verifique com `ls -la`

* Loop de links: Use `readlink -f` para resolver

* Links não seguidos: Adicione `-L` aos comandos

### 📊 Diagnóstico

```BASH
# Verificação completa
namei -l /caminho/do/link    # Mostra cadeia completa
stat -L link                # Info do arquivo linkado
file -L link               # Tipo do arquivo linkado
```

## Próximos Passos

1. [Monitoramento de Arquivos](file-monitoring.html)

2. [Operações em Lote](batch-operations.html)

3. [Troubleshooting](file-ops-troubleshooting.html)

Tip:

"Links são como portais no sistema de arquivos - use-os com sabedoria."

```
LINKS VERIFICADOS
[████████████] 100%
SISTEMA: CONECTADO
INTEGRIDADE: OK
```



# Monitoramento de Arquivos: Vigilância em Tempo Real 👀

## Ferramentas de Monitoramento

### 🔍 Inotify

```BASH
# Monitoramento básico
inotifywait -m /path/to/watch    # Monitor simples
inotifywait -m -r /path         # Recursivo
inotifywait -m -e modify,create,delete /path  # Eventos específicos

# Monitor com logging
inotifywait -m /path | while read dir event file; do
    echo "$(date): $event em $file" >> /var/log/file_changes.log
done
```

### 🕵️ Watch

```BASH
# Monitoramento periódico
watch -n 1 ls -l /path          # Atualiza a cada segundo
watch -d ls -l /path           # Destaca mudanças
watch -g 'ls -l | wc -l'      # Para quando houver mudança
```

## Scripts de Monitoramento

### 📝 Monitor de Mudanças

```BASH
#!/bin/bash
# change_monitor.sh

monitor_directory() {
    local dir="${1:-.}"
    local log="${2:-changes.log}"
    
    inotifywait -m -r -e modify,create,delete "$dir" |
    while read -r directory events filename; do
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $events: $directory$filename" >> "$log"
        
        case "$events" in
            MODIFY) handle_modify "$directory$filename" ;;
            CREATE) handle_create "$directory$filename" ;;
            DELETE) handle_delete "$directory$filename" ;;
        esac
    done
}

handle_modify() {
    local file="$1"
    echo "Arquivo modificado: $file"
    # Adicione ações específicas aqui
}

handle_create() {
    local file="$1"
    echo "Novo arquivo: $file"
    # Adicione ações específicas aqui
}

handle_delete() {
    local file="$1"
    echo "Arquivo removido: $file"
    # Adicione ações específicas aqui
}
```

### 🔄 Backup Automático

```BASH
#!/bin/bash
# auto_backup.sh

watch_and_backup() {
    local src="$1"
    local backup_dir="$2"
    
    inotifywait -m -r -e modify,create "$src" |
    while read -r directory events filename; do
        timestamp=$(date +%Y%m%d_%H%M%S)
        cp -a "$directory$filename" "$backup_dir/${filename}_${timestamp}"
        echo "Backup criado: ${filename}_${timestamp}"
    done
}
```

## Alertas e Notificações

### 📧 Notificações por Email

```BASH
#!/bin/bash
# notify_changes.sh

notify_admin() {
    local message="$1"
    local subject="Alerta de Arquivo"
    local admin_email="admin@example.com"
    
    echo "$message" | mail -s "$subject" "$admin_email"
}

monitor_critical() {
    local critical_dir="$1"
    
    inotifywait -m -r -e modify,delete "$critical_dir" |
    while read -r directory events filename; do
        notify_admin "Alerta: $events em $directory$filename"
    done
}
```

### 📱 Integração com Sistemas

```BASH
#!/bin/bash
# integration.sh

send_webhook() {
    local event="$1"
    local webhook_url="https://webhook.example.com"
    
    curl -X POST "$webhook_url" \
        -H "Content-Type: application/json" \
        -d "{\"event\":\"$event\"}"
}
```

## Análise de Logs

### 📊 Processamento de Logs

```BASH
#!/bin/bash
# log_analyzer.sh

analyze_changes() {
    local log_file="$1"
    
    echo "=== Resumo de Mudanças ==="
    echo "Modificações:"
    grep MODIFY "$log_file" | wc -l
    
    echo "Criações:"
    grep CREATE "$log_file" | wc -l
    
    echo "Deleções:"
    grep DELETE "$log_file" | wc -l
}
```

## Exercícios Práticos

### 🎯 Missão 1: Sistema de Vigilância

```BASH
# Crie um sistema que:
# 1. Monitore múltiplos diretórios
# 2. Registre todas as mudanças
# 3. Envie alertas críticos
# 4. Mantenha histórico de mudanças
```

### 🎯 Missão 2: Backup Inteligente

```BASH
# Desenvolva um sistema que:
# 1. Monitore arquivos importantes
# 2. Faça backup automático
# 3. Mantenha versões
# 4. Limpe backups antigos
```

## Troubleshooting

### 🔧 Problemas Comuns

* Alto uso de CPU: Limite eventos monitorados

* Memória insuficiente: Reduza diretórios monitorados

* Perda de eventos: Use buffer maior

* Permissões: Verifique acesso aos diretórios

### 📋 Checklist de Verificação

```BASH
# Verificações básicas
systemctl status inotify   # Status do serviço
sysctl -a | grep inotify  # Limites do sistema
lsof | grep inotify      # Processos usando inotify
```

## Próximos Passos

1. [Operações em Lote](batch-operations.html)

2. [File-Ops Troubleshooting](file-ops-troubleshooting.html)

3. [System Monitoring](system-monitoring.html)

Tip:

"Vigilância constante é o preço da segurança dos dados."

```
MONITOR ATIVO
[▓▓▓▓▓▓▓▓▓▓] 100%
STATUS: VIGILANTE
EVENTOS: REGISTRANDO
```



# Operações em Lote: Poder do Processamento em Massa 🚀

## Ferramentas Fundamentais

### 🔍 Find e Xargs

```BASH
# Operações básicas
find . -type f -name "*.log" -exec rm {} \;    # Remove logs
find . -mtime +30 | xargs rm -f               # Remove arquivos antigos
find . -size +100M -exec mv {} /backup/ \;    # Move arquivos grandes
```

### 📋 Parallel

```BASH
# Processamento paralelo
find . -type f | parallel gzip     # Compacta em paralelo
cat lista.txt | parallel wget {}   # Downloads paralelos
ls *.jpg | parallel convert {} {.}.png  # Conversão em massa
```

## Scripts de Processamento

### 🔄 Processador em Lote

```BASH
#!/bin/bash
# batch_processor.sh

process_files() {
    local dir="$1"
    local pattern="$2"
    local action="$3"
    local max_procs="${4:-4}"
    
    find "$dir" -type f -name "$pattern" | \
    parallel -j "$max_procs" "$action"
}

# Exemplo de uso:
# process_files /data "*.txt" "gzip" 8
```

### 📦 Compactação em Massa

```BASH
#!/bin/bash
# mass_compress.sh

compress_directory() {
    local src="$1"
    local dest="${2:-compressed}"
    local threads="${3:-$(nproc)}"
    
    mkdir -p "$dest"
    
    find "$src" -type f -size +1M | \
    parallel -j "$threads" \
        "gzip -c {} > $dest/{/.}.gz"
}
```

## Transformação de Dados

### 📊 Processamento de Texto

```BASH
#!/bin/bash
# text_processor.sh

process_text_files() {
    local pattern="$1"
    local search="$2"
    local replace="$3"
    
    find . -type f -name "$pattern" | \
    parallel sed -i "s/$search/$replace/g" {}
}
```

### 🖼️ Processamento de Imagens

```BASH
#!/bin/bash
# image_processor.sh

process_images() {
    local dir="$1"
    local size="$2"
    
    find "$dir" -type f \( -name "*.jpg" -o -name "*.png" \) | \
    parallel convert {} -resize "$size" {}_resized
}
```

## Otimização e Performance

### ⚡ Controle de Recursos

```BASH
#!/bin/bash
# resource_control.sh

batch_with_limits() {
    local cmd="$1"
    local max_load="$2"
    local max_procs="$3"
    
    parallel --load "$max_load" \
             --jobs "$max_procs" \
             "$cmd"
}
```

### 🎯 Monitoramento de Progresso

```BASH
#!/bin/bash
# progress_monitor.sh

monitor_progress() {
    local total="$1"
    local current="$2"
    local width=50
    
    local percent=$((current * 100 / total))
    local filled=$((width * current / total))
    
    printf "\rProgresso: [%-${width}s] %d%%" \
           "$(printf '#%.0s' $(seq 1 "$filled"))" "$percent"
}
```

## Exercícios Práticos

### 🎯 Missão 1: Processamento de Logs

```BASH
# Desenvolva um sistema que:
# 1. Encontre logs antigos
# 2. Comprima em paralelo
# 3. Mova para armazenamento
# 4. Gere relatório
```

### 🎯 Missão 2: Transformação de Dados

```BASH
# Crie um pipeline que:
# 1. Processe múltiplos formatos
# 2. Aplique transformações
# 3. Valide resultados
# 4. Gere backups
```

## Troubleshooting

### 🔧 Problemas Comuns

* Sobrecarga do sistema: Ajuste número de processos

* Erros de permissão: Verifique acessos

* Memória insuficiente: Controle tamanho do lote

* Deadlocks: Implemente timeouts

### 📋 Checklist de Verificação

```BASH
# Verificações do sistema
uptime                 # Carga do sistema
free -h               # Memória disponível
df -h                # Espaço em disco
ulimit -a           # Limites do sistema
```

## Próximos Passos

1. [File-Ops Troubleshooting](file-ops-troubleshooting.html)

2. [System Monitoring](system-monitoring.html)

3. [Performance Tuning](null)

Tip:

"Automatize o repetitivo, foque no criativo."

```
PROCESSAMENTO EM LOTE
[⚡⚡⚡⚡⚡⚡⚡⚡] 100%
EFICIÊNCIA: MÁXIMA
RECURSOS: OTIMIZADOS
```



# Troubleshooting de Operações com Arquivos 🔧

## Diagnóstico Sistemático

### 🔍 Verificação Inicial

```BASH
# Checagem básica
ls -la                    # Permissões e propriedade
df -h                    # Espaço em disco
pwd                     # Confirma diretório atual
whoami                 # Confirma usuário atual
```

### 📊 Análise Detalhada

```BASH
# Investigação profunda
strace cp arquivo1 arquivo2    # Debug de sistema
lsof arquivo                  # Arquivos abertos
fuser -v arquivo            # Processos usando arquivo
iostat -x 1               # Monitoramento de I/O
```

## Problemas Comuns e Soluções

### 🚫 Permissão Negada

```BASH
# Diagnóstico
namei -l /caminho/completo    # Verifica cadeia de permissões
getfacl arquivo              # Lista ACLs
sudo -l                     # Lista permissões sudo

# Correção
chmod u+rw arquivo          # Adiciona permissões
chown usuario:grupo arquivo # Muda proprietário
setfacl -m u:usuario:rw arquivo  # Configura ACL
```

### 💾 Espaço em Disco

```BASH
# Análise
du -sh * | sort -hr         # Uso por diretório
find . -size +100M         # Arquivos grandes
ncdu                      # Navegador de uso

# Limpeza
find . -name "*.tmp" -delete  # Remove temporários
journalctl --vacuum-time=2d  # Limpa logs antigos
docker system prune        # Limpa Docker
```

### 🔒 Arquivos Travados

```BASH
# Identificação
lsof | grep arquivo         # Processos usando
fuser -k arquivo          # Mata processos (cuidado!)

# Liberação
sync                     # Sincroniza buffers
umount -l /montagem     # Desmonta forçado
```

### 🔗 Links Quebrados

```BASH
# Detecção
find . -type l -! -exec test -e {} \; -print  # Links quebrados
readlink -f link                             # Resolve link

# Correção
ln -sf alvo link        # Recria link simbólico
find . -xtype l -delete # Remove links quebrados
```

## Scripts de Diagnóstico

### 📝 Verificador de Sistema de Arquivos

```BASH
#!/bin/bash
# fs_check.sh

check_filesystem() {
    local path="${1:-.}"
    
    echo "=== Verificação do Sistema de Arquivos ==="
    echo "Diretório: $path"
    echo
    
    echo "1. Espaço em Disco:"
    df -h "$path"
    echo
    
    echo "2. Permissões Suspeitas:"
    find "$path" -type f -perm /o+w
    echo
    
    echo "3. Links Quebrados:"
    find "$path" -type l -! -exec test -e {} \; -print
    echo
    
    echo "4. Arquivos Grandes (>100MB):"
    find "$path" -type f -size +100M -exec ls -lh {} \;
}
```

### 🔄 Monitor de Operações

```BASH
#!/bin/bash
# ops_monitor.sh

monitor_operations() {
    local file="$1"
    
    echo "Monitorando operações em $file..."
    
    inotifywait -m "$file" |
    while read -r directory events filename; do
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $events"
        
        case "$events" in
            OPEN) check_open "$file" ;;
            MODIFY) check_modify "$file" ;;
            ACCESS) check_access "$file" ;;
        esac
    done
}
```

## Prevenção e Manutenção

### 🛡️ Backup Automático

```BASH
#!/bin/bash
# auto_backup.sh

backup_before_operation() {
    local file="$1"
    local backup_dir="${2:-./backup}"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    
    mkdir -p "$backup_dir"
    cp -a "$file" "$backup_dir/${file##*/}_$timestamp"
}
```

### 📋 Checklist de Manutenção

```BASH
# Verificações Diárias
find /var/log -type f -mtime +30 -delete  # Limpa logs
find /tmp -type f -mtime +7 -delete      # Limpa temporários
du -sh /* | sort -hr > disk_usage.log   # Relatório de disco
```

## Exercícios Práticos

### 🎯 Missão 1: Sistema de Diagnóstico

```BASH
# Desenvolva um sistema que:
# 1. Monitore operações críticas
# 2. Detecte problemas comuns
# 3. Aplique correções automáticas
# 4. Mantenha logs de troubleshooting
```

### 🎯 Missão 2: Recuperação de Desastres

```BASH
# Crie um plano que:
# 1. Identifique falhas críticas
# 2. Implemente backups automáticos
# 3. Defina procedimentos de recuperação
# 4. Teste cenários de falha
```

## Próximos Passos

1. [System Monitoring](system-monitoring.html)

2. [Backup Strategies](null)

3. [Disaster Recovery](null)

Tip:

"O melhor troubleshooting é aquele que previne problemas antes que aconteçam."

```
DIAGNÓSTICO
[🔍🔍🔍🔍🔍] 100%
STATUS: RESOLVIDO
SISTEMA: ESTÁVEL
```



# Processamento de Texto

Note:

Todos os exemplos de processamento de texto estão disponíveis em `code/module2/text-proc/text_processing.sh`. Pratique cada comando para dominar o processamento de texto.

```
PROCESSADOR DE TEXTO INICIADO...
===============================
STATUS: PRONTO PARA PROCESSAR
MODO: TRANSFORMAÇÃO DE DADOS
===============================
```

## Ferramentas Fundamentais

### 🔍 Busca e Filtragem

```BASH
# Busca com grep
grep "padrão" arquivo.txt     # Busca básica
grep -i "TEXTO" *.log        # Case insensitive
grep -r "TODO" .             # Busca recursiva
grep -v "excluir" dados.txt  # Inverte seleção
```

### ✏️ Edição e Substituição

```BASH
# Substituição com sed
sed 's/antigo/novo/' arquivo.txt    # Primeira ocorrência
sed 's/antigo/novo/g' arquivo.txt   # Todas ocorrências
sed -i 's/erro/log/' *.txt         # Edição in-place
sed '1,5d' arquivo.txt             # Remove linhas 1-5
```

### 🔧 Processamento com AWK

```BASH
# Processamento de campos
awk '{print $1}' dados.txt         # Primeiro campo
awk '{print $NF}' arquivo.txt      # Último campo
awk -F: '{print $1,$3}' /etc/passwd # Define separador
awk '$3 > 100' números.txt         # Filtra valores
```

## Filtros de Texto

### 📊 Ordenação e Contagem

```BASH
# Manipulação básica
sort arquivo.txt              # Ordena linhas
sort -n números.txt          # Ordena numericamente
uniq -c lista.txt           # Conta ocorrências
wc -l arquivo.txt           # Conta linhas
```

### ✂️ Extração e Transformação

```BASH
# Manipulação de campos
cut -d',' -f1,3 dados.csv   # Extrai campos
tr 'a-z' 'A-Z' < texto.txt  # Converte case
paste arq1.txt arq2.txt     # Combina arquivos
join -t',' arq1.txt arq2.txt # Join de arquivos
```

## Pipeline de Processamento

### 🔄 Combinando Comandos

```BASH
# Análise complexa
cat log.txt | \
    grep "ERROR" | \
    cut -d' ' -f3 | \
    sort | uniq -c | \
    sort -nr

# Extração de dados
cat access.log | \
    awk '{print $1}' | \
    sort | uniq -c | \
    sort -nr | head -10
```

### 📈 Análise de Dados

```BASH
# Estatísticas básicas
cat números.txt | \
    awk '{ sum += $1 } 
         END { 
           print "Soma:", sum;
           print "Média:", sum/NR 
         }'

# Contagem de palavras
cat texto.txt | \
    tr -cs '[:alpha:]' '\n' | \
    tr '[:upper:]' '[:lower:]' | \
    sort | uniq -c | sort -nr
```

## Exercícios Práticos

### 🎯 Missão 1: Análise de Logs

```BASH
#!/bin/bash
# Analise um arquivo de log e extraia:
# 1. Top 10 IPs com mais acessos
# 2. Requisições com erro (código 5xx)
# 3. Total de bytes transferidos
# 4. Horários de pico de acesso
```

### 🎯 Missão 2: Processamento de CSV

```BASH
#!/bin/bash
# Processe um arquivo CSV para:
# 1. Calcular média por coluna
# 2. Filtrar registros específicos
# 3. Transformar formato dos dados
# 4. Gerar relatório resumido
```

## Próximos Passos

1. [Expressões Regulares](regular-expressions.html)

2. [Automação de Processamento](text-processing-automation.html)

3. [Análise Avançada](text-analysis.html)

Tip:

"Texto é o DNA dos dados. Processá-lo é entender a vida do sistema."

```
PROCESSAMENTO
[⚙️⚙️⚙️⚙️⚙️] 100%
STATUS: TEXTO DOMINADO
PRÓXIMO: REGEX AVANÇADO
```

## Referências Rápidas

### 📚 Comandos Essenciais

* `grep`: Busca padrões em texto

* `sed`: Editor de stream

* `awk`: Processamento de texto por padrões

* `sort`: Ordenação de linhas

* `uniq`: Remove duplicatas

* `cut`: Extrai campos

* `tr`: Traduz/substitui caracteres

* `join`: Combina arquivos por campo comum

* `paste`: Combina arquivos linha a linha

* `wc`: Conta linhas, palavras e caracteres

### 🚀 Dicas de Performance

1. Use `grep -v` ao invés de `sed '/padrão/d'`

2. Prefira `awk` para cálculos numéricos

3. Combine comandos com pipes

4. Use `sort -u` ao invés de `sort | uniq`

5. Aproveite o poder das regex



# Fundamentos do Grep 🔍

Note:

O grep é uma ferramenta poderosa para busca de padrões em texto. Seu nome vem de "Global Regular Expression Print".

## Sintaxe Básica

### 🎯 Busca Simples

```BASH
grep "palavra" arquivo.txt      # Busca básica
grep "erro" *.log              # Busca em múltiplos arquivos
grep "padrão" arquivo1 arquivo2 # Busca em arquivos específicos
cat arquivo.txt | grep "texto"  # Busca via pipe
```

## Opções Essenciais

### 🛠️ Flags Comuns

```BASH
grep -i "TEXTO"    # Ignora case
grep -v "excluir"  # Inverte seleção
grep -n "linha"    # Mostra número da linha
grep -c "contar"   # Conta ocorrências
grep -w "palavra"  # Palavra exata
```

### 📂 Busca em Diretórios

```BASH
grep -r "texto" .           # Busca recursiva
grep -R "config" /etc      # Segue symlinks
grep -l "padrão" *.txt     # Lista arquivos
grep -L "ausente" *.conf   # Arquivos sem match
```

## Contexto e Formatação

### 👀 Exibindo Contexto

```BASH
grep -A 2 "erro"    # 2 linhas após
grep -B 3 "início"  # 3 linhas antes
grep -C 1 "meio"    # 1 linha antes e depois
```

### 🎨 Formatação da Saída

```BASH
grep --color "destaque"     # Colorir matches
grep -h "sem-arquivo"       # Omite nome do arquivo
grep -H "com-arquivo"       # Força nome do arquivo
```

## Padrões Básicos

### 🎨 Caracteres Especiais

```BASH
grep "^início"     # Começa com
grep "fim$"        # Termina com
grep "^$"          # Linhas vazias
grep "."           # Qualquer caractere
```

### 🎲 Quantificadores

```BASH
grep "ca*t"        # 'ct', 'cat', 'caat'...
grep "ca\?"        # 'c', 'ca'
grep "ca\+"        # 'ca', 'caa'...
```

## Exemplos Práticos

### 📊 Análise de Logs

```BASH
# Encontra erros em logs
grep "ERROR" /var/log/*.log

# Busca IPs em access.log
grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" access.log

# Encontra requisições POST
grep -i "POST" access.log
```

### 🔧 Manutenção de Sistema

```BASH
# Busca processos
ps aux | grep "nginx"

# Encontra configurações
grep -r "DocumentRoot" /etc/apache2/

# Busca usuários
grep "bash$" /etc/passwd
```

## Exercícios Práticos

### 🎯 Missão 1: Análise de Log

```BASH
# Objetivos:
# 1. Encontre todas as linhas com "ERROR"
# 2. Mostre 2 linhas de contexto
# 3. Salve resultado em erro.log
grep -C 2 "ERROR" app.log > erro.log
```

### 🎯 Missão 2: Busca Avançada

```BASH
# Objetivos:
# 1. Busque recursivamente por "TODO"
# 2. Apenas em arquivos .py
# 3. Ignore case
find . -name "*.py" -exec grep -i "TODO" {} \;
```

## Dicas de Performance

### ⚡ Otimizações

1. Use `grep -F` para strings fixas

2. Evite recursão desnecessária

3. Combine com `find` para maior controle

4. Use `--exclude` e `--include` para filtrar

### 🚫 Armadilhas Comuns

1. Esquecimento de aspas

2. Uso incorreto de regex

3. Recursão em diretórios grandes

4. Ignorar case quando necessário

## Próximos Passos

1. [Expressões Regulares](regular-expressions.html)

2. [Sed Básico](sed-basics.html)

3. [Awk Básico](awk-basics.html)

Tip:

"grep é como uma lupa para seu texto - quanto melhor você a usa, mais detalhes encontra."

```
GREP MASTERY
[🔍🔍🔍🔍🔍] 100%
STATUS: PADRÕES DOMINADOS
PRÓXIMO: REGEX AVANÇADO
```



# Fundamentos do Sed

Note:

Aprenda os conceitos básicos e uso do comando sed para manipulação eficiente de texto.

## Sintaxe Básica

### 🎯 Comandos Fundamentais

```BASH
sed 's/antigo/novo/'        # Substitui primeira ocorrência
sed 's/antigo/novo/g'       # Substitui todas ocorrências
sed '3s/antigo/novo/'       # Substitui na linha 3
sed '1,5s/antigo/novo/'     # Substitui nas linhas 1-5
```

### 🔄 Flags de Substituição

```BASH
s/padrão/texto/g           # Global (todas ocorrências)
s/padrão/texto/i           # Ignora case
s/padrão/texto/p           # Imprime linhas modificadas
s/padrão/texto/w arquivo   # Salva linhas modificadas
```

## Operações Básicas

### ✂️ Deletar Linhas

```BASH
sed '3d'                   # Deleta linha 3
sed '2,5d'                # Deleta linhas 2-5
sed '/padrão/d'           # Deleta linhas com padrão
sed '/^$/d'              # Deleta linhas vazias
```

### ➕ Adicionar Linhas

```BASH
sed '2i\TEXTO'            # Insere antes da linha 2
sed '2a\TEXTO'            # Insere após linha 2
sed '2c\TEXTO'            # Substitui linha 2
```

## Padrões e Endereços

### 🎯 Seleção de Linhas

```BASH
sed -n '1p'               # Imprime linha 1
sed -n '1,5p'            # Imprime linhas 1-5
sed -n '/erro/p'         # Imprime linhas com 'erro'
sed '/início/,/fim/p'    # Imprime entre padrões
```

### 🔍 Expressões Regulares

```BASH
sed '/^#/d'              # Remove comentários
sed '/^$/d'              # Remove linhas vazias
sed '/[0-9]\{3\}/p'     # Mostra linhas com 3 dígitos
```

## Manipulação Avançada

### 💾 Grupos e Referências

```BASH
# Inverte palavras
sed 's/\([a-z]*\) \([a-z]*\)/\2 \1/'

# Formata telefone
sed 's/\([0-9]\{2\}\)\([0-9]\{4\}\)\([0-9]\{4\}\)/(\1) \2-\3/'

# Adiciona aspas
sed 's/\(.*\)/"\1"/'
```

### 🔄 Múltiplos Comandos

```BASH
# Vários comandos em sequência
sed -e 's/foo/bar/' -e 's/bar/baz/'

# Usando ponto e vírgula
sed 's/foo/bar/;s/bar/baz/'

# De um arquivo
sed -f comandos.sed arquivo.txt
```

## Exemplos Práticos

### 📝 Manipulação de Arquivos

```BASH
# Comenta linhas específicas
sed '2,5s/^/#/'

# Remove espaços extras
sed 's/  */ /g'

# Adiciona numeração
sed = arquivo.txt | sed 'N;s/\n/. /'
```

### 🔧 Transformação de Dados

```BASH
# Converte CSV para TSV
sed 's/,/\t/g'

# Formata JSON
sed 's/},{/},\n{/g'

# Limpa HTML
sed 's/<[^>]*>//g'
```

## Exercícios Práticos

### 🎯 Missão 1: Limpeza de Logs

```BASH
#!/bin/bash
# Objetivos:
# 1. Remover linhas vazias
# 2. Remover timestamps
# 3. Formatar saída

sed -e '/^$/d' \
    -e 's/^\[[0-9: -]*\] //' \
    -e 's/ERROR/*** ERROR ***/' \
    log.txt
```

### 🎯 Missão 2: Formatação de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Converter dados para CSV
# 2. Adicionar cabeçalho
# 3. Formatar campos

sed -e '1i\Nome,Idade,Email' \
    -e 's/|/,/g' \
    -e 's/^ *//' \
    -e 's/ *$//' \
    dados.txt
```

## Dicas e Truques

### 💡 Boas Práticas

1. Use `-E` para regex estendido

2. Faça backup antes de editar in-place

3. Teste comandos antes com `-n`

4. Quebre comandos complexos em partes

### ⚠️ Armadilhas Comuns

1. Esquecimento de flags globais

2. Escape incorreto de caracteres

3. Ordem errada de operações

4. Uso excessivo de grupos

## Ferramentas Úteis

### 🛠️ Depuração

```BASH
# Mostra mudanças
sed -n 'p;s/foo/bar/p' 

# Debug com comentários
sed -n 'l' # mostra caracteres especiais

# Teste de padrões
sed --debug 's/padrão/texto/'
```

### 📚 Referências

1. [GNU Sed Manual](https://www.gnu.org/software/sed/manual/sed.html)

2. [Sed One-Liners](http://sed.sourceforge.net/sed1line.txt)

3. [POSIX Sed Standard](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html)

Tip:

"Sed é como um canivete suíço para texto - pequeno, mas incrivelmente versátil."

```
SED MASTERY
[✂️✂️✂️✂️✂️] 100%
STATUS: TRANSFORMAÇÕES DOMINADAS
PRÓXIMO: AWK BÁSICO
```



# Fundamentos do AWK 📊

Note:

AWK é uma linguagem de programação projetada para processamento de texto, especialmente poderosa para trabalhar com dados tabulares.

## Sintaxe Básica

### 🎯 Estrutura Fundamental

```BASH
# Formato básico
awk 'padrão { ação }' arquivo.txt

# Exemplos simples
awk '{print $1}' dados.txt      # Primeiro campo
awk '{print $NF}' arquivo.txt   # Último campo
awk '{print NR, $0}' texto.txt  # Número da linha e conteúdo
```

### 🔄 Separadores de Campo

```BASH
# Separador padrão (espaço/tab)
awk '{print $1, $2}' dados.txt

# Definindo separador
awk -F: '{print $1}' /etc/passwd
awk -F',' '{print $1}' dados.csv
awk 'BEGIN{FS=":"} {print $1}' arquivo.txt
```

## Variáveis Especiais

### 📝 Variáveis Internas

```BASH
NR      # Número da linha atual
NF      # Número de campos na linha
$0      # Linha inteira
$1-$n   # Campos individuais
FILENAME # Nome do arquivo atual
FS      # Separador de campo (input)
OFS     # Separador de campo (output)
RS      # Separador de registro (input)
ORS     # Separador de registro (output)
```

## Padrões e Ações

### 🎯 Seleção de Linhas

```BASH
# Filtragem básica
awk 'NR==1' arquivo.txt         # Primeira linha
awk 'NR>1' arquivo.txt          # Pula cabeçalho
awk '/padrão/' arquivo.txt      # Linhas com padrão
awk 'length>80' arquivo.txt     # Linhas longas
```

### 🔢 Operações Matemáticas

```BASH
# Soma de coluna
awk '{sum += $1} END {print sum}' números.txt

# Média
awk '{sum += $1} END {print sum/NR}' dados.txt

# Contagem
awk '{count[$1]++} END {for (i in count) print i, count[i]}' log.txt
```

## Controle de Fluxo

### 🔄 Estruturas de Controle

```BASH
# If-else
awk '{
    if ($3 > 100) 
        print "Alto: " $0
    else 
        print "Baixo: " $0
}' dados.txt

# Loops
awk '{
    for (i=1; i<=NF; i++) 
        print $i
}' arquivo.txt
```

### 🎬 Blocos Especiais

```BASH
# BEGIN - antes de processar
awk 'BEGIN {print "Iniciando..."} 
     {print $0} 
     END {print "Fim!"}' arquivo.txt

# END - após processar
awk '{sum += $1} 
     END {print "Total:", sum}' números.txt
```

## Funções Integradas

### 📚 Funções de String

```BASH
# Manipulação de texto
length($0)           # Comprimento
substr($1, 1, 3)     # Substring
toupper($1)          # Maiúsculas
tolower($1)          # Minúsculas
gsub(/a/, "b")       # Substituição global
```

### 🔢 Funções Matemáticas

```BASH
# Operações matemáticas
int($1)              # Parte inteira
sqrt($1)             # Raiz quadrada
rand()               # Número aleatório
sin($1), cos($1)     # Trigonometria
```

## Exemplos Práticos

### 📊 Análise de Dados

```BASH
# Estatísticas básicas
awk '
    {
        sum += $1
        if(min == "" || $1 < min) min = $1
        if(max == "" || $1 > max) max = $1
    }
    END {
        print "Min:", min
        print "Max:", max
        print "Média:", sum/NR
    }
' dados.txt
```

### 📝 Processamento de Logs

```BASH
# Análise de log Apache
awk '
    /ERROR/ {errors++}
    /WARNING/ {warnings++}
    END {
        print "Erros:", errors
        print "Avisos:", warnings
    }
' access.log
```

## Exercícios Práticos

### 🎯 Missão 1: Análise de CSV

```BASH
# Objetivos:
# 1. Calcular média por coluna
# 2. Encontrar valores máximos
# 3. Contar ocorrências únicas

awk -F',' '
    {
        sum[$1] += $2
        count[$1]++
    }
    END {
        for (i in sum)
            print i, sum[i]/count[i]
    }
' dados.csv
```

### 🎯 Missão 2: Formatação de Saída

```BASH
# Objetivos:
# 1. Formatar tabela
# 2. Alinhar colunas
# 3. Adicionar cabeçalho

awk 'BEGIN {
        printf "%-20s %10s %10s\n", "Nome", "Valor", "Total"
        print "----------------------------------------"
    }
    {
        printf "%-20s %10.2f %10.2f\n", $1, $2, $2 * $3
    }' dados.txt
```

## Dicas e Truques

### 💡 Boas Práticas

1. Use variáveis descritivas

2. Quebre scripts longos em funções

3. Comente código complexo

4. Valide entrada de dados

### ⚠️ Armadilhas Comuns

1. Esquecimento de aspas

2. Confusão com separadores

3. Não tratamento de erros

4. Overhead em arquivos grandes

## Próximos Passos

1. [Expressões Regulares Avançadas](null)

2. [AWK Scripts Complexos](null)

3. [Integração com Sed](null)

Tip:

"AWK é como uma calculadora programável para seus dados - quanto mais você aprende, mais poderosa ela se torna."

```
AWK MASTERY
[🔢🔢🔢🔢🔢] 100%
STATUS: DADOS DOMINADOS
PRÓXIMO: PROCESSAMENTO AVANÇADO
```



# Filtros de Texto 🔍

Note:

Domine os filtros essenciais para manipulação e transformação de texto no terminal.

## Filtros Básicos

### 🔤 Ordenação

```BASH
# sort - ordenação de linhas
sort arquivo.txt              # Ordem alfabética
sort -n números.txt          # Ordem numérica
sort -r lista.txt           # Ordem reversa
sort -k2 dados.txt          # Ordena pela coluna 2
sort -u nomes.txt           # Remove duplicatas
```

### 📊 Contagem e Estatísticas

```BASH
# uniq - remove/conta duplicatas
uniq -c lista.txt           # Conta ocorrências
uniq -d repetidos.txt       # Mostra só duplicatas
uniq -u únicos.txt         # Mostra só únicos

# wc - conta linhas/palavras/caracteres
wc arquivo.txt              # Todas contagens
wc -l logs/*.log           # Conta linhas
wc -w texto.txt            # Conta palavras
wc -c dados.bin            # Conta bytes
```

## Filtros de Transformação

### ✂️ Extração de Campos

```BASH
# cut - extrai colunas
cut -d',' -f1,3 dados.csv   # Campos 1 e 3
cut -c1-10 arquivo.txt      # Primeiros 10 chars
cut -d':' -f1 /etc/passwd   # Extrai usernames

# paste - combina arquivos
paste arq1.txt arq2.txt     # Lado a lado
paste -d',' *.txt           # Une com vírgula
paste -s números.txt        # Uma linha
```

### 🔄 Transformação de Caracteres

```BASH
# tr - traduz/deleta caracteres
tr 'a-z' 'A-Z' < texto.txt  # Maiúsculas
tr -d '\r' < dos.txt        # Remove CR
tr -s '\n' < dados.txt      # Comprime vazios
tr '[:space:]' ',' < arq    # Espaços para vírgulas

# expand/unexpand - tabs/espaços
expand arquivo.txt          # Tab para espaços
unexpand -a texto.txt      # Espaços para tab
```

## Filtros Avançados

### 🎯 Seleção de Linhas

```BASH
# head/tail - início/fim do arquivo
head -n 5 arquivo.txt       # Primeiras 5 linhas
tail -f log.txt            # Monitora arquivo
head -c 1K dados.bin       # Primeiros 1K bytes
tail -n +10 arquivo.txt    # A partir da linha 10

# sed como filtro
sed -n '10,20p' arquivo    # Linhas 10-20
sed '/^$/d' texto.txt      # Remove vazias
```

### 📝 Formatação de Saída

```BASH
# column - formata em colunas
column -t dados.txt         # Alinha colunas
column -s',' -t dados.csv   # CSV em tabela
column -n arquivo.txt       # Numera linhas

# fmt - formata parágrafos
fmt -w 60 texto.txt         # Largura 60
fmt -u arquivo.txt         # Uniforme
```

## Combinando Filtros

### 🔄 Pipelines Comuns

```BASH
# Análise de logs
cat access.log | \
    cut -d' ' -f1 | \
    sort | uniq -c | \
    sort -nr | head -10

# Processamento de CSV
cat dados.csv | \
    tr -d '\r' | \
    cut -d',' -f2,4 | \
    sort -t',' -k1 | \
    uniq > resultado.csv
```

### 📊 Análise de Dados

```BASH
# Estatísticas básicas
cat números.txt | \
    sort -n | \
    awk '
        BEGIN {print "Análise Numérica"}
        {sum += $1; values[NR] = $1}
        END {
            print "Min:", values[1]
            print "Max:", values[NR]
            print "Média:", sum/NR
        }'

# Contagem de palavras
cat texto.txt | \
    tr -cs '[:alpha:]' '\n' | \
    tr '[:upper:]' '[:lower:]' | \
    sort | uniq -c | sort -nr
```

## Exercícios Práticos

### 🎯 Missão 1: Análise de Logs

```BASH
#!/bin/bash
# Objetivos:
# 1. Extrair IPs únicos
# 2. Contar códigos HTTP
# 3. Calcular bytes transferidos
# 4. Identificar User Agents

cat access.log | \
    awk '{print $1}' | sort -u > ips.txt

cat access.log | \
    cut -d'"' -f3 | cut -d' ' -f1 | \
    sort | uniq -c | sort -nr
```

### 🎯 Missão 2: Processamento de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Limpar dados CSV
# 2. Extrair colunas específicas
# 3. Remover duplicatas
# 4. Formatar saída

cat dados.csv | \
    tr -d '\r' | \
    cut -d',' -f1,3,5 | \
    sort -t',' -k1 | uniq | \
    column -s',' -t > limpo.txt
```

## Dicas e Truques

### 💡 Boas Práticas

1. Use `sort | uniq` em vez de apenas `uniq`

2. Prefira `cut` a `awk` para extrações simples

3. Use `column -t` para saída legível

4. Monitore logs com `tail -f`

5. Combine filtros com pipes

### ⚠️ Armadilhas Comuns

1. Esquecimento de ordenar antes do `uniq`

2. Problemas com delimitadores

3. Encoding incorreto

4. Consumo excessivo de memória

## Próximos Passos

1. [Expressões Regulares](regular-expressions.html)

2. [AWK Avançado](null)

3. [Sed Avançado](null)

Tip:

"Filtros são como LEGO: simples sozinhos, poderosos quando combinados."

```
FILTER MASTERY
[⚡⚡⚡⚡⚡] 100%
STATUS: FILTROS DOMINADOS
PRÓXIMO: REGEX AVANÇADO
```



# Expressões Regulares 🎯

Note:

Expressões Regulares (regex) são padrões de busca poderosos que permitem encontrar e manipular texto de forma precisa.

## Fundamentos

### 🎨 Caracteres Básicos

```BASH
.        # Qualquer caractere único
^        # Início da linha
$        # Fim da linha
\        # Escape de caracteres especiais
[]       # Conjunto de caracteres
[^]      # Negação do conjunto
```

### 🔢 Quantificadores

```BASH
*        # Zero ou mais (0+)
+        # Um ou mais (1+)
?        # Zero ou um (0-1)
{n}      # Exatamente n
{n,}     # n ou mais
{n,m}    # Entre n e m
```

## Classes de Caracteres

### 📝 Classes Predefinidas

```BASH
\w       # Caractere de palavra [a-zA-Z0-9_]
\W       # Não-palavra [^a-zA-Z0-9_]
\d       # Dígito [0-9]
\D       # Não-dígito [^0-9]
\s       # Espaço em branco [ \t\n\r\f]
\S       # Não-espaço [^ \t\n\r\f]
```

### 🎯 Conjuntos Personalizados

```BASH
[aeiou]  # Qualquer vogal
[0-9]    # Qualquer dígito
[A-Z]    # Letra maiúscula
[a-z]    # Letra minúscula
[^0-9]   # Qualquer não-dígito
```

## Padrões Comuns

### 📧 Validações Úteis

```BASH
# Email
^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$

# IP
^([0-9]{1,3}\.){3}[0-9]{1,3}$

# Data (DD/MM/YYYY)
^([0-2][0-9]|3[0-1])/(0[1-9]|1[0-2])/[0-9]{4}$

# URL
^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$
```

## Uso com Grep

### 🔍 Busca Avançada

```BASH
# Encontra emails
grep -E '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}' arquivo.txt

# Encontra IPs
grep -E '^([0-9]{1,3}\.){3}[0-9]{1,3}$' ips.txt

# Encontra datas
grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}' logs.txt
```

### ⚡ Flags Úteis

```BASH
grep -E  # Extended regex
grep -P  # Perl regex (mais recursos)
grep -v  # Inverte match
grep -i  # Ignora case
```

## Uso com Sed

### ✏️ Substituições

```BASH
# Substitui emails
sed -E 's/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/EMAIL/g'

# Formata datas
sed -E 's/([0-9]{2})\/([0-9]{2})\/([0-9]{4})/\3-\2-\1/g'

# Remove linhas vazias
sed -E '/^[[:space:]]*$/d'
```

## Exercícios Práticos

### 🎯 Missão 1: Validação

```BASH
#!/bin/bash
# Crie expressões regulares para validar:
# 1. Números de telefone
# 2. CPF/CNPJ
# 3. Nomes de usuário
# 4. Senhas fortes

# Exemplo de validação de telefone
telefone='^(\+55|0)?([0-9]{2})?[0-9]{8,9}$'
if [[ $1 =~ $telefone ]]; then
    echo "Telefone válido"
fi
```

### 🎯 Missão 2: Extração

```BASH
#!/bin/bash
# Extraia de um arquivo de log:
# 1. Todos os IPs únicos
# 2. Todas as URLs acessadas
# 3. Todos os códigos de erro
# 4. Timestamps em formato específico

# Exemplo de extração de IPs
grep -Eo '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' access.log | sort -u
```

## Dicas e Truques

### 💡 Boas Práticas

1. Teste suas regex em pequenas amostras

2. Use grupos de captura com moderação

3. Prefira classes predefinidas quando possível

4. Documente padrões complexos

5. Considere performance em grandes arquivos

### ⚠️ Armadilhas Comuns

1. Greedy vs Lazy matching

2. Escape de caracteres especiais

3. Complexidade excessiva

4. Falsos positivos/negativos

## Ferramentas Úteis

### 🛠️ Testadores Online

1. regex101.com

2. regexr.com

3. debuggex.com

### 📚 Referências

1. [Documentação POSIX ERE](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html)

2. [Perl Regular Expressions](https://perldoc.perl.org/perlre)

3. [GNU Regex Syntax](https://www.gnu.org/software/grep/manual/html_node/Regular-Expressions.html)

Tip:

"Uma expressão regular é como uma chave: quanto mais precisa, melhor abre a fechadura."

```
REGEX MASTERY
[🎯🎯🎯🎯🎯] 100%
STATUS: PADRÕES DOMINADOS
PRÓXIMO: SED AVANÇADO
```



# Manipulação de Texto

Note:

Aprenda técnicas avançadas para manipulação e transformação de texto no terminal.

## Transformações Básicas

### 🔄 Substituição de Texto

```BASH
# Substituições simples
tr 'a-z' 'A-Z' < texto.txt     # Converte para maiúsculas
tr -d '\r' < arquivo.dos       # Remove retornos de carro
tr -s '[:space:]' ' '          # Comprime espaços

# Substituições com sed
sed 's/antigo/novo/g'          # Substitui todas ocorrências
sed 's/^/    /'               # Indenta linhas
sed 's/[[:space:]]*$//'       # Remove espaços no fim
```

### ✂️ Recorte e Junção

```BASH
# Manipulação de linhas
cut -d',' -f1-3 dados.csv     # Seleciona campos
paste arq1 arq2               # Combina arquivos
join -t',' arq1 arq2          # Join em campo comum
split -l 1000 arquivo.txt     # Divide em arquivos menores
```

## Transformações Avançadas

### 📊 Formatação de Dados

```BASH
# Conversão de formatos
# CSV para TSV
sed 's/,/\t/g' dados.csv

# JSON para linha única
tr -d '\n' < dados.json | \
    sed 's/} /}\n/g'

# Tabela para CSV
column -t -s'|' dados.txt | \
    sed 's/  */,/g'
```

### 🔠 Manipulação de Strings

```BASH
# Operações com strings
# Extrai substring
cut -c1-10 arquivo.txt

# Inverte string
rev texto.txt

# Capitaliza primeira letra
sed 's/\b\(.\)/\u\1/g'

# Remove caracteres especiais
tr -cd '[:alnum:][:space:]'
```

## Casos de Uso Comuns

### 📝 Limpeza de Dados

```BASH
# Pipeline de limpeza
cat dados.txt | \
    tr -d '\r' | \                  # Remove CR
    tr -s '[:space:]' ' ' | \       # Normaliza espaços
    sed 's/^ *//;s/ *$//' | \       # Remove espaços
    grep -v '^$' | \                # Remove linhas vazias
    tr '[:upper:]' '[:lower:]'      # Converte case
```

### 🔍 Extração de Informações

```BASH
# Extrai emails
grep -Eo '[[:alnum:].]+@[[:alnum:].]+\.[[:alpha:]]{2,}'

# Extrai URLs
grep -Eo 'https?://[^[:space:]]+'

# Extrai números de telefone
grep -Eo '[0-9]{2}[ -]?[0-9]{4,5}[-]?[0-9]{4}'
```

## Automação de Tarefas

### 📋 Templates e Substituição

```BASH
# Template com variáveis
cat template.txt | \
    sed "s/{{nome}}/$NOME/g" | \
    sed "s/{{data}}/$DATA/g" | \
    sed "s/{{versao}}/$VERSAO/g"

# Geração de código
cat << EOF > config.json
{
    "app": "$APP_NAME",
    "version": "$VERSION",
    "env": "$ENV"
}
EOF
```

### 🔄 Processamento em Lote

```BASH
# Renomeia arquivos em lote
for f in *.txt; do
    mv "$f" "${f%.txt}.md"
done

# Processa múltiplos arquivos
find . -name "*.log" -type f | \
    while read file; do
        sed -i 's/ERROR/ERRO/g' "$file"
    done
```

## Exercícios Práticos

### 🎯 Missão 1: Formatação de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Converter CSV para formato tabular
# 2. Alinhar colunas
# 3. Adicionar cabeçalho
# 4. Numerar linhas

cat dados.csv | \
    tr ',' '\t' | \
    column -t | \
    nl -w3 -s'. ' > tabela.txt
```

### 🎯 Missão 2: Transformação de Logs

```BASH
#!/bin/bash
# Objetivos:
# 1. Extrair campos específicos
# 2. Formatar timestamps
# 3. Categorizar eventos
# 4. Gerar relatório

cat access.log | \
    awk '{print $4, $6, $7}' | \
    sed 's/\[//;s/\]//' | \
    sort -k1,1 | \
    uniq -c > report.txt
```

## Dicas e Truques

### 💡 Boas Práticas

1. Faça backup antes de transformações

2. Use expressões regulares com moderação

3. Teste em amostra pequena primeiro

4. Documente transformações complexas

5. Mantenha scripts reutilizáveis

### ⚠️ Armadilhas Comuns

1. Encoding incorreto

2. Caracteres especiais não tratados

3. Substituições muito agressivas

4. Perda de dados não intencional

## Próximos Passos

1. [Análise de Texto](text-analysis.html)

2. [Automação de Processamento](text-processing-automation.html)

3. [Expressões Regulares Avançadas](null)

Tip:

"A arte da manipulação de texto está em transformar dados brutos em informação útil."

```
TEXT MANIPULATION
[🔧🔧🔧🔧🔧] 100%
STATUS: TRANSFORMADOR DE TEXTO
PRÓXIMO: ANÁLISE AVANÇADA
```



# Análise de Texto 📊

Note:

Aprenda técnicas avançadas para analisar e extrair insights de dados textuais.

## Análise Básica

### 📊 Estatísticas de Texto

```BASH
# Contagens básicas
wc -l arquivo.txt           # Total de linhas
wc -w texto.txt            # Total de palavras
wc -c dados.txt            # Total de caracteres

# Análise de vocabulário
cat texto.txt | \
    tr -cs '[:alpha:]' '\n' | \
    sort | uniq -c | \
    sort -nr | head -10     # Top 10 palavras
```

### 📈 Análise Numérica

```BASH
# Estatísticas numéricas
cat números.txt | \
    sort -n | \
    awk '
        BEGIN { print "=== Análise Numérica ===" }
        { 
            sum += $1
            values[NR] = $1 
        }
        END {
            print "Mínimo:", values[1]
            print "Máximo:", values[NR]
            print "Total:", sum
            print "Média:", sum/NR
            print "Registros:", NR
        }'
```

## Análise de Logs

### 🔍 Padrões de Acesso

```BASH
# Análise de logs de acesso
cat access.log | \
    awk '{print $1}' | \
    sort | uniq -c | \
    sort -nr | head -10     # Top 10 IPs

# Códigos de status HTTP
cat access.log | \
    awk '{print $9}' | \
    sort | uniq -c | \
    sort -nr                # Distribuição de status
```

### ⚠️ Análise de Erros

```BASH
# Detecção de erros
grep -i "error" error.log | \
    awk -F'[][]' '{print $2}' | \
    sort | uniq -c | \
    sort -nr                # Tipos de erro

# Timeline de erros
grep -i "error" error.log | \
    awk '{print $1, $2}' | \
    sort -k1,2              # Ordenado por timestamp
```

## Análise de Dados

### 📊 Análise de CSV

```BASH
# Estatísticas por coluna
awk -F',' '
    NR > 1 {               # Pula cabeçalho
        sum[$1] += $2      # Soma por categoria
        count[$1]++        # Conta ocorrências
    }
    END {
        for (cat in sum)
            print cat, sum[cat]/count[cat]
    }' dados.csv | sort -k2nr

# Filtragem e agregação
awk -F',' '$3 > 1000 {     # Filtra valores
    sum += $4              # Soma coluna 4
    count++                # Conta registros
} END {
    print "Média:", sum/count
}' dados.csv
```

### 📈 Séries Temporais

```BASH
# Análise por período
awk '
    {
        hora = substr($4, 14, 2)    # Extrai hora
        count[hora]++               # Conta por hora
    }
    END {
        for (h in count)
            print h, count[h]
    }' access.log | sort -n

# Tendências
cat métricas.log | \
    awk '{print $1, $2}' | \
    sort -k1,1 | \
    awk '
        {
            sum += $2
            values[NR] = $2
        }
        END {
            print "Tendência:", 
            values[NR] > values[1] ? "↑" : "↓"
        }'
```

## Ferramentas de Análise

### 🔧 Scripts Úteis

```BASH
#!/bin/bash
# Análise completa de texto
analyze_text() {
    local file=$1
    echo "=== Análise de $file ==="
    echo "Linhas: $(wc -l < "$file")"
    echo "Palavras: $(wc -w < "$file")"
    echo "Caracteres: $(wc -c < "$file")"
    echo "Top 5 palavras:"
    tr -cs '[:alpha:]' '\n' < "$file" | \
        sort | uniq -c | sort -nr | head -5
}

# Análise de performance
analyze_perf() {
    local log=$1
    echo "=== Performance ==="
    awk '
        $9 >= 500 { erros++ }
        { tempo += $10 }
        END {
            print "Erros:", erros
            print "Tempo médio:", tempo/NR
        }' "$log"
}
```

### 📊 Visualização Básica

```BASH
# Histograma ASCII
cat dados.txt | \
    sort -n | uniq -c | \
    awk '{ printf "%3d: %s\n", $2, 
          repeat("█", int($1/5)) }
    function repeat(s,n) {
        return n <= 0 ? "" : s repeat(s,n-1)
    }'

# Gráfico de barras
cat stats.txt | \
    awk '{ printf "%-10s |%s\n", $1,
          repeat("=", int($2/100)) }
    function repeat(s,n) {
        return n <= 0 ? "" : s repeat(s,n-1)
    }'
```

## Exercícios Práticos

### 🎯 Missão 1: Análise de Logs

```BASH
#!/bin/bash
# Objetivos:
# 1. Identificar padrões de acesso
# 2. Detectar anomalias
# 3. Gerar relatório de performance
# 4. Visualizar tendências

analyze_logs() {
    local log=$1
    # Sua implementação aqui
}
```

### 🎯 Missão 2: Análise de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Calcular estatísticas
# 2. Identificar outliers
# 3. Gerar visualizações
# 4. Exportar relatório

analyze_data() {
    local data=$1
    # Sua implementação aqui
}
```

## Próximos Passos

1. [Automação de Análise](text-processing-automation.html)

2. [Visualização Avançada](null)

3. [Machine Learning Básico](null)

Tip:

"Dados são apenas dados até serem analisados. Depois, tornam-se conhecimento."

```
TEXT ANALYSIS
[📊📊📊📊📊] 100%
STATUS: ANALISTA DE DADOS
PRÓXIMO: AUTOMAÇÃO AVANÇADA
```



# Automação de Processamento de Texto

Note:

Aprenda a automatizar tarefas repetitivas de processamento de texto com scripts e ferramentas eficientes.

## Scripts de Processamento

### 🔄 Processamento em Lote

```BASH
#!/bin/bash
# Processa múltiplos arquivos
process_files() {
    local dir=$1
    local pattern=$2
    
    find "$dir" -type f -name "$pattern" | while read -r file; do
        echo "Processando: $file"
        # Remove linhas vazias
        sed -i '/^$/d' "$file"
        # Converte para minúsculas
        tr '[:upper:]' '[:lower:]' < "$file" > "${file}.tmp"
        mv "${file}.tmp" "$file"
        # Remove espaços extras
        sed -i 's/[[:space:]]\+/ /g' "$file"
    done
}

# Uso: process_files "./logs" "*.log"
```

### 📝 Transformação de Dados

```BASH
#!/bin/bash
# Converte formatos de dados
convert_data() {
    local input=$1
    local output=$2
    local format=$3

    case $format in
        "csv2json")
            awk -F',' '
                BEGIN { print "[" }
                NR == 1 { 
                    split($0, headers)
                    next 
                }
                {
                    printf "  {"
                    for (i=1; i<=NF; i++)
                        printf "\"%s\": \"%s\"%s", 
                               headers[i], $i, 
                               (i==NF ? "" : ",")
                    print "}" (NR==NR ? "" : ",")
                }
                END { print "]" }
            ' "$input" > "$output"
            ;;
        "json2csv")
            # Implementar conversão JSON para CSV
            ;;
    esac
}
```

## Monitoramento e Processamento

### 👀 Monitoramento de Arquivos

```BASH
#!/bin/bash
# Monitor de mudanças em arquivos
watch_and_process() {
    local dir=$1
    local pattern=$2
    local cmd=$3

    inotifywait -m -e modify,create "$dir" |
        while read -r directory events filename; do
            if [[ "$filename" =~ $pattern ]]; then
                echo "Mudança detectada em: $filename"
                eval "$cmd \"$directory/$filename\""
            fi
        done
}

# Uso: watch_and_process "./logs" "*.log" "process_log"
```

### 🔄 Processamento Contínuo

```BASH
#!/bin/bash
# Processamento em tempo real
stream_process() {
    local input=$1
    
    tail -f "$input" | while read -r line; do
        # Processa cada linha em tempo real
        echo "$line" | \
            grep -v '^#' | \
            awk '{print strftime("%Y-%m-%d %H:%M:%S"), $0}'
    done
}
```

## Templates e Geradores

### 📋 Geração de Relatórios

```BASH
#!/bin/bash
# Gerador de relatórios
generate_report() {
    local data=$1
    local template=$2
    local output=$3

    # Carrega template
    cat "$template" | while read -r line; do
        # Substitui variáveis
        line=${line//\{\{DATA\}\}/$(date +%Y-%m-%d)}
        line=${line//\{\{STATS\}\}/$(calculate_stats "$data")}
        echo "$line" >> "$output"
    done
}

# Template exemplo:
# Relatório de {{DATA}}
# ===================
# Estatísticas:
# {{STATS}}
```

### 🔧 Processamento Customizado

```BASH
#!/bin/bash
# Framework de processamento
process_framework() {
    local input=$1
    local config=$2

    # Carrega configurações
    source "$config"

    # Pipeline de processamento
    cat "$input" | \
        ${PRE_PROCESS:-cat} | \
        ${MAIN_PROCESS:-cat} | \
        ${POST_PROCESS:-cat} > \
        "${input}.processed"
}

# Arquivo de configuração exemplo:
# PRE_PROCESS="tr -d '\r'"
# MAIN_PROCESS="awk -F',' '{print \$1,\$3}'"
# POST_PROCESS="sort | uniq"
```

## Automação Avançada

### 🚀 Paralelização

```BASH
#!/bin/bash
# Processamento paralelo
parallel_process() {
    local dir=$1
    local workers=${2:-4}

    find "$dir" -type f -name "*.txt" | \
        parallel --jobs "$workers" \
        'echo "Processando {}"; process_file "{}"'
}

# Processamento em lotes
batch_process() {
    local input=$1
    local batch_size=${2:-1000}
    
    split -l "$batch_size" "$input" temp_batch_
    ls temp_batch_* | parallel process_batch
    rm temp_batch_*
}
```

### 📊 Agregação de Resultados

```BASH
#!/bin/bash
# Combina resultados
aggregate_results() {
    local dir=$1
    local pattern=$2

    # Cabeçalho
    echo "Data,Total,Média,Máximo" > resultados.csv

    # Combina e processa resultados
    find "$dir" -name "$pattern" -type f | \
        while read -r file; do
            awk -F',' '
                NR > 1 {
                    sum += $2
                    if ($2 > max) max = $2
                    count++
                }
                END {
                    printf "%s,%.2f,%.2f,%.2f\n",
                        FILENAME, sum, sum/count, max
                }' "$file" >> resultados.csv
        done
}
```

## Exercícios Práticos

### 🎯 Missão 1: Pipeline de Logs

```BASH
#!/bin/bash
# Objetivos:
# 1. Monitorar diretório de logs
# 2. Processar novos arquivos
# 3. Gerar alertas
# 4. Arquivar processados

# Implementação básica
monitor_logs() {
    watch_and_process "./logs" "*.log" \
        'process_log "{}" && \
         generate_alert "{}" && \
         archive_log "{}"'
}
```

### 🎯 Missão 2: ETL Automatizado

```BASH
#!/bin/bash
# Objetivos:
# 1. Extrair dados de múltiplas fontes
# 2. Transformar formatos
# 3. Carregar em destino
# 4. Validar resultados

# Implementação básica
etl_pipeline() {
    extract_data
    transform_data
    load_data
    validate_results
}
```

## Dicas e Boas Práticas

### 💡 Recomendações

1. Use funções para código reutilizável

2. Implemente logging adequado

3. Trate erros apropriadamente

4. Documente configurações

5. Faça backup antes de processamentos

### ⚠️ Pontos de Atenção

1. Monitore uso de recursos

2. Implemente timeouts

3. Valide entradas

4. Teste com amostras pequenas

5. Mantenha logs de execução

## Próximos Passos

1. [Processamento Distribuído](null)

2. [Integração com APIs](null)

3. [Orquestração de Workflows](null)

Tip:

"Automatize o repetitivo, foque no criativo."

```
AUTOMATION MASTER
[🤖🤖🤖🤖🤖] 100%
STATUS: AUTOMAÇÃO DOMINADA
PRÓXIMO: PROCESSAMENTO DISTRIBUÍDO
```



# Informações do Sistema

Note:

Consulte `code/module2/system/system_info.sh` para uma coleção completa de comandos para monitoramento e análise do sistema.

```
SCANNER DE SISTEMA ATIVADO...
===========================
STATUS: MONITORANDO
ALCANCE: SISTEMA COMPLETO
===========================
```

## Informações Básicas do Sistema

### 🔍 Identificação do Sistema

```BASH
# Informações do sistema operacional
uname -a                # Todas as informações do sistema
hostnamectl            # Informações detalhadas do host
lsb_release -a         # Informações da distribuição
cat /etc/os-release    # Detalhes da versão do SO

# Hardware
lscpu                  # Informações da CPU
lsmem                  # Informações da memória
lspci                  # Dispositivos PCI
lsusb                  # Dispositivos USB
```

### 📊 Recursos do Sistema

```BASH
# CPU e Memória
top                    # Visão geral interativa
htop                   # Interface melhorada
free -h                # Uso de memória
vmstat 1               # Estatísticas virtuais
uptime                 # Tempo de atividade e carga

# Disco
df -h                  # Uso do sistema de arquivos
du -sh /*              # Uso de disco por diretório
iostat                 # Estatísticas de I/O
lsblk                  # Informações de blocos
```

## Monitoramento de Recursos

### 💻 CPU e Processamento

```BASH
# Monitoramento de CPU
mpstat -P ALL 1        # Estatísticas por CPU
sar -u 1 5            # Uso de CPU (5 amostras)
pidstat                # Estatísticas por processo

# Carga do sistema
w                      # Quem está logado e o que está fazendo
ps aux                 # Lista de processos
pstree                # Árvore de processos
```

### 🧠 Memória e Swap

```BASH
# Análise de memória
free -h                # Visão geral da memória
vmstat -s              # Estatísticas detalhadas
swapon --show         # Informações de swap
smem                  # Uso de memória por processo
```

## Rede e Conectividade

### 🌐 Informações de Rede

```BASH
# Configuração de rede
ip addr                # Endereços IP
ip route              # Tabela de roteamento
netstat -tuln         # Portas abertas
ss -tuln              # Sockets ativos (alternativa moderna)

# Diagnóstico
ping -c 4 8.8.8.8     # Teste de conectividade
traceroute google.com # Rota até o destino
dig google.com        # Consulta DNS
mtr google.com        # Combinação ping + traceroute
```

## Scripts de Análise

### 📈 Monitor de Sistema

```BASH
#!/bin/bash
# system_monitor.sh

system_overview() {
    echo "=== Sistema ==="
    uname -a
    
    echo -e "\n=== CPU ==="
    top -bn1 | head -n 3
    
    echo -e "\n=== Memória ==="
    free -h
    
    echo -e "\n=== Disco ==="
    df -h
    
    echo -e "\n=== Rede ==="
    netstat -tuln
}

# Uso: system_overview
```

### 📊 Relatório de Recursos

```BASH
#!/bin/bash
# resource_report.sh

generate_report() {
    local output="system_report_$(date +%Y%m%d).txt"
    
    {
        echo "Relatório do Sistema - $(date)"
        echo "=========================="
        
        echo -e "\n1. Informações do Sistema"
        hostnamectl
        
        echo -e "\n2. CPU"
        lscpu | grep -E "^CPU\(s\)|^Model name"
        
        echo -e "\n3. Memória"
        free -h
        
        echo -e "\n4. Disco"
        df -h
        
        echo -e "\n5. Processos Top 5 (CPU)"
        ps aux --sort=-%cpu | head -n 6
        
        echo -e "\n6. Processos Top 5 (Memória)"
        ps aux --sort=-%mem | head -n 6
        
    } > "$output"
    
    echo "Relatório gerado: $output"
}
```

## Ferramentas Avançadas

### 🔧 Diagnóstico Avançado

```BASH
# Análise de Performance
perf stat program     # Estatísticas de performance
strace command       # Trace de chamadas do sistema
ltrace program       # Trace de chamadas de biblioteca
```

### 🔍 Análise de Logs

```BASH
# Visualização de Logs
journalctl           # Logs do sistema (systemd)
tail -f /var/log/syslog  # Logs em tempo real
grep -r "error" /var/log/* # Busca por erros
```

## Exercícios Práticos

### 🎯 Missão 1: Monitor Completo

```BASH
#!/bin/bash
# Objetivos:
# 1. Monitorar CPU, memória e disco
# 2. Gerar alertas para limites
# 3. Manter histórico
# 4. Gerar relatórios

# Implementação básica
monitor_all() {
    while true; do
        check_cpu
        check_memory
        check_disk
        sleep 60
    done
}
```

### 🎯 Missão 2: Análise de Performance

```BASH
#!/bin/bash
# Objetivos:
# 1. Coletar métricas de performance
# 2. Identificar gargalos
# 3. Gerar recomendações
# 4. Documentar resultados
```

## Dicas e Boas Práticas

### 💡 Recomendações

1. Monitore regularmente

2. Mantenha histórico

3. Configure alertas

4. Documente mudanças

5. Automatize verificações

### ⚠️ Pontos de Atenção

1. Impacto do monitoramento

2. Segurança dos dados

3. Retenção de logs

4. Uso de recursos

5. Privacidade

## Próximos Passos

1. [Performance Tuning](null)

2. [System Monitoring](system-monitoring.html)

3. [Troubleshooting](troubleshooting.html)

Tip:

"Conhecer seu sistema é o primeiro passo para otimizá-lo."

```
SYSTEM MASTER
[🖥️🖥️🖥️🖥️🖥️] 100%
STATUS: SISTEMA DOMINADO
PRÓXIMO: PERFORMANCE TUNING
```



# Scripts e Automação: Dominando o Poder do Shell 🚀

```
INICIANDO MÓDULO DE SCRIPTING...
===============================
STATUS: MODO AUTOMAÇÃO
NÍVEL: INTERMEDIÁRIO
PODER: MULTIPLICANDO
===============================
```

## Visão Geral do Módulo

Neste módulo, você aprenderá a criar scripts poderosos para automatizar tarefas e multiplicar sua produtividade no terminal.

### 🎯 Objetivos

* Criar scripts bash eficientes e reutilizáveis

* Dominar variáveis e tipos de dados

* Implementar estruturas de controle

* Desenvolver funções modulares

## Roteiro de Aprendizado

### 

1. [Fundamentos de Scripts](script-basics.html)

* Estrutura básica de scripts

* Shebang e permissões

* Boas práticas

* Debug e troubleshooting

### 

2. [Variáveis e Tipos](variables-and-types.html)

* Declaração e escopo

* Tipos de dados

* Arrays e associative arrays

* Manipulação de strings

### 

3. [Estruturas de Controle](control-structures.html)

* Condicionais (if, case)

* Loops (for, while, until)

* Break e continue

* Exit status

### 

4. [Funções](functions.html)

* Definição e chamada

* Parâmetros e retorno

* Escopo de variáveis

* Bibliotecas de funções

## Exemplos Práticos

### 🛠️ Script Básico

```BASH
#!/bin/bash

# Script de exemplo
echo "Iniciando script..."

# Variáveis
nome="Terminal Master"
versao="1.0"

# Função
saudacao() {
    echo "Olá, $1!"
}

# Uso
saudacao "$nome"
```

### 🔄 Fluxo de Trabalho

```BASH
#!/bin/bash

# Exemplo de fluxo completo
processar_arquivos() {
    local dir="$1"
    
    # Loop
    for arquivo in "$dir"/*; do
        # Condicional
        if [[ -f "$arquivo" ]]; then
            echo "Processando: $arquivo"
        fi
    done
}
```

## Melhores Práticas

### ✅ Do's

* Use nomes descritivos

* Documente seu código

* Trate erros adequadamente

* Modularize seu código

* Teste exaustivamente

### ❌ Don'ts

* Hardcode valores

* Ignorar códigos de retorno

* Esquecer de validar input

* Negligenciar permissões

* Usar variáveis não declaradas

## Próximos Passos

1. [Automação Avançada](null)

2. [Integração com Sistema](null)

3. [Projetos Práticos](null)

Tip:

"Automatize tudo o que puder. Seu futuro eu agradecerá."

```
CARREGANDO PODER DE SCRIPT...
[████████████████] 100%
STATUS: PRONTO PARA AUTOMATIZAR
PRÓXIMA MISSÃO: SCRIPT BASICS
```



# Fundamentos de Scripts: Primeiros Passos 📝

## Estrutura Básica

### 🚀 Primeiro Script

```BASH
#!/bin/bash
# Meu primeiro script

echo "Hello, World!"
```

### 📋 Anatomia de um Script

```BASH
#!/bin/bash
# Autor: Seu Nome
# Data: YYYY-MM-DD
# Descrição: Descrição do script

# Variáveis
VERSAO="1.0"
CONFIG_FILE="/etc/config.conf"

# Funções
verificar_ambiente() {
    # código aqui
    return 0
}

# Código principal
main() {
    echo "Iniciando script..."
    verificar_ambiente
}

# Execução
main "$@"
```

## Permissões e Execução

### 🔒 Configurando Permissões

```BASH
# Tornar script executável
chmod +x script.sh

# Permissões específicas
chmod 755 script.sh  # rwxr-xr-x
```

### 🎯 Modos de Execução

```BASH
# Diferentes formas de executar
./script.sh         # Executável
bash script.sh      # Interpretador explícito
source script.sh    # Carregar no shell atual
. script.sh         # Forma curta do source
```

## Debug e Troubleshooting

### 🐛 Modo Debug

```BASH
#!/bin/bash -x    # Debug completo
set -x            # Iniciar debug
set +x            # Parar debug

# Debug seletivo
set -x
comando_complexo
set +x
```

### ⚠️ Tratamento de Erros

```BASH
# Strict mode
set -euo pipefail

# Tratamento de erros
if ! comando; then
    echo "Erro ao executar comando" >&2
    exit 1
fi
```

## Boas Práticas

### 📚 Documentação

```BASH
#!/bin/bash
# 
# Nome: MeuScript
# Descrição: Faz algo incrível
# Uso: ./meu_script.sh [opções]
# Opções:
#   -h  Mostra ajuda
#   -v  Modo verbose
```

### 🎯 Validação de Input

```BASH
# Verificar argumentos
if [[ $# -lt 1 ]]; then
    echo "Erro: Argumentos insuficientes" >&2
    echo "Uso: $0 arquivo" >&2
    exit 1
fi

# Verificar arquivo
if [[ ! -f "$1" ]]; then
    echo "Erro: Arquivo não encontrado: $1" >&2
    exit 1
fi
```

## Exercícios Práticos

### 🎯 Missão 1: Script Básico

```BASH
#!/bin/bash
# Criar um script que:
# 1. Aceite um argumento
# 2. Valide o input
# 3. Execute uma ação
# 4. Trate erros
```

### 🎯 Missão 2: Debug

```BASH
#!/bin/bash
# Objetivos:
# 1. Adicionar modo debug
# 2. Implementar logs
# 3. Tratar erros
# 4. Testar diferentes cenários
```

## Próximos Passos

1. [Variáveis e Tipos](variables-and-types.html)

2. [Estruturas de Controle](control-structures.html)

3. [Funções](functions.html)

Tip:

"Todo script poderoso começa com um bom shebang."

```
FUNDAMENTOS CARREGADOS
[██████████░░░░] 60%
STATUS: APRENDENDO
PRÓXIMO: VARIÁVEIS
```



# Variáveis e Tipos: Dominando os Dados 📊

## Variáveis Básicas

### 📝 Declaração e Atribuição

```BASH
# Declaração básica
nome="Terminal Master"
idade=25
ativo=true

# Declaração explícita
declare -i numero=42    # Inteiro
declare -r CONSTANTE="Valor"  # Readonly
declare -l minusculo="TEXTO"  # Lowercase
declare -u MAIUSCULO="texto"  # Uppercase
```

### 🔄 Escopo de Variáveis

```BASH
# Variável local
local_var="Local"

# Variável global
GLOBAL_VAR="Global"

# Variável de ambiente
export ENV_VAR="Environment"
```

## Tipos de Dados

### 🔢 Números

```BASH
# Inteiros
declare -i numero=42
((numero++))
((resultado = numero * 2))

# Operações aritméticas
soma=$((5 + 3))
produto=$((4 * 3))
divisao=$((10 / 2))
modulo=$((15 % 4))
```

### 📝 Strings

```BASH
# Manipulação de strings
texto="Hello World"
tamanho=${#texto}
substring=${texto:0:5}
substituir=${texto/World/Bash}

# Concatenação
nome="Terminal"
sobrenome="Master"
completo="$nome $sobrenome"
```

### 📚 Arrays

```BASH
# Array simples
frutas=("maçã" "banana" "laranja")
echo "${frutas[0]}"      # Primeiro elemento
echo "${frutas[@]}"      # Todos elementos
echo "${#frutas[@]}"     # Tamanho do array

# Array associativo
declare -A usuarios
usuarios[admin]="root"
usuarios[user]="guest"
```

## Manipulação de Variáveis

### 🔧 Operações com Variáveis

```BASH
# Expansão de variáveis
echo ${var:-default}     # Valor default
echo ${var:=default}     # Atribuir default
echo ${var:?erro}        # Erro se não definida
echo ${var:+valor}       # Valor se definida

# Manipulação de strings
echo ${var#prefixo}      # Remove prefixo
echo ${var%sufixo}       # Remove sufixo
echo ${var/old/new}      # Substitui primeira ocorrência
echo ${var//old/new}     # Substitui todas ocorrências
```

### 📊 Validação e Teste

```BASH
# Testes de variáveis
[[ -z "$var" ]]         # Vazia?
[[ -n "$var" ]]         # Não vazia?
[[ "$a" == "$b" ]]      # Iguais?
[[ "$num" -eq 42 ]]     # Igual (números)?
```

## Exercícios Práticos

### 🎯 Missão 1: Manipulação de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Criar e manipular arrays
# 2. Processar strings
# 3. Realizar operações matemáticas
# 4. Validar dados
```

### 🎯 Missão 2: Processamento de Dados

```BASH
#!/bin/bash
# Objetivos:
# 1. Ler dados de arquivo
# 2. Processar informações
# 3. Armazenar em estruturas
# 4. Gerar relatório
```

## Melhores Práticas

### ✅ Recomendações

1. Use nomes descritivos

2. Declare tipos quando possível

3. Inicialize variáveis

4. Valide dados de entrada

5. Use constantes apropriadamente

### ⚠️ Armadilhas Comuns

1. Espaços na atribuição

2. Variáveis não declaradas

3. Escopo incorreto

4. Tipo de dados errado

5. Falta de aspas

## Próximos Passos

1. [Estruturas de Controle](control-structures.html)

2. [Funções](functions.html)

3. [Manipulação Avançada](null)

Tip:

"Variáveis são como caixas mágicas: o conteúdo importa mais que o rótulo."

```
TIPOS DE DADOS CARREGADOS
[████████████░░] 80%
STATUS: PROCESSANDO
PRÓXIMO: CONTROLE DE FLUXO
```



# Estruturas de Controle: Dominando o Fluxo 🔄

## Condicionais

### 🔍 If/Else

```BASH
# Estrutura básica
if [[ condição ]]; then
    comando
elif [[ outra_condição ]]; then
    outro_comando
else
    comando_final
fi

# Exemplo prático
if [[ -f "$arquivo" ]]; then
    echo "Arquivo existe"
elif [[ -d "$arquivo" ]]; then
    echo "É um diretório"
else
    echo "Não encontrado"
fi
```

### 🔀 Case

```BASH
# Estrutura case
case "$variavel" in
    padrão1)
        comandos
        ;;
    padrão2|padrão3)
        outros_comandos
        ;;
    *)
        comando_default
        ;;
esac

# Exemplo prático
case "$opcao" in
    start|--start)
        iniciar_servico
        ;;
    stop|--stop)
        parar_servico
        ;;
    *)
        mostrar_ajuda
        ;;
esac
```

## Loops

### 🔁 For

```BASH
# Loop básico
for i in {1..5}; do
    echo "$i"
done

# Loop em array
for elemento in "${array[@]}"; do
    processar "$elemento"
done

# Loop C-style
for ((i=0; i<10; i++)); do
    echo "$i"
done
```

### 🔄 While

```BASH
# Loop while básico
while [[ condição ]]; do
    comandos
done

# Exemplo: ler arquivo
while IFS= read -r linha; do
    processar "$linha"
done < "arquivo.txt"

# Loop infinito
while true; do
    monitorar_sistema
    sleep 1
done
```

### 🔁 Until

```BASH
# Loop until
until [[ condição ]]; do
    comandos
done

# Exemplo prático
count=0
until [[ $count -ge 5 ]]; do
    echo "$count"
    ((count++))
done
```

## Controle de Fluxo

### ⏹️ Break e Continue

```BASH
# Break
for i in {1..10}; do
    if [[ $i -eq 5 ]]; then
        break
    fi
    echo "$i"
done

# Continue
for i in {1..5}; do
    if [[ $i -eq 3 ]]; then
        continue
    fi
    echo "$i"
done
```

### 🚪 Exit

```BASH
# Saída com status
if [[ erro ]]; then
    echo "Erro encontrado" >&2
    exit 1
fi

# Saída condicional
[[ $# -eq 0 ]] && { echo "Argumentos necessários"; exit 1; }
```

## Exercícios Práticos

### 🎯 Missão 1: Controle de Fluxo

```BASH
#!/bin/bash
# Objetivos:
# 1. Implementar menu interativo
# 2. Processar múltiplos arquivos
# 3. Validar entradas
# 4. Tratar erros
```

### 🎯 Missão 2: Automação

```BASH
#!/bin/bash
# Objetivos:
# 1. Monitorar recursos
# 2. Processar logs
# 3. Backup automático
# 4. Relatórios periódicos
```

## Melhores Práticas

### ✅ Recomendações

1. Use condições claras

2. Evite loops infinitos

3. Trate casos especiais

4. Valide entradas

5. Use exit codes apropriados

### ⚠️ Armadilhas Comuns

1. Loops infinitos acidentais

2. Condições mal formadas

3. Break/continue mal utilizados

4. Exit codes incorretos

5. Falta de tratamento de erro

## Próximos Passos

1. [Funções](functions.html)

2. [Tratamento de Erros](null)

3. [Otimização](null)

Tip:

"O fluxo de controle é como água: sempre encontra seu caminho."

```
CONTROLE DE FLUXO DOMINADO
[███████████████] 90%
STATUS: FLUINDO
PRÓXIMO: FUNÇÕES
```



# Funções: Modularizando seu Código 🧩

## Fundamentos

### 📝 Declaração Básica

```BASH
# Função simples
hello() {
    echo "Hello, World!"
}

# Função com parâmetros
saudacao() {
    echo "Olá, $1!"
}

# Função com retorno
soma() {
    local resultado=$(($1 + $2))
    echo "$resultado"
}
```

### 🎯 Parâmetros e Argumentos

```BASH
# Parâmetros posicionais
funcao() {
    echo "Primeiro: $1"
    echo "Segundo: $2"
    echo "Todos: $@"
    echo "Número de args: $#"
}

# Parâmetros nomeados
config() {
    local nome=${1:-"default"}
    local tipo=${2:-"normal"}
    echo "Nome: $nome, Tipo: $tipo"
}
```

## Escopo e Retorno

### 🔒 Variáveis Locais

```BASH
# Escopo local
processa_dados() {
    local temp_var="local"
    echo "$temp_var"
}

# Escopo global
GLOBAL_VAR="global"
modifica_global() {
    GLOBAL_VAR="modificado"
}
```

### ↩️ Valores de Retorno

```BASH
# Retorno numérico
verifica_status() {
    [[ -f "$1" ]] && return 0
    return 1
}

# Retorno de string
get_info() {
    local info
```



# Administração do Sistema Linux 🖥️

Note:

Este módulo aborda as principais tarefas e responsabilidades na administração de sistemas Linux.

## Visão Geral

A administração de sistemas Linux envolve quatro áreas principais:

1. Gerenciamento de Usuários - Controle de contas e permissões

2. Controle de Processos - Monitoramento e gerenciamento de processos

3. Monitoramento do Sistema - Acompanhamento de recursos e performance

4. Administração de Rede - Configuração e manutenção de conectividade

## Ferramentas Essenciais

### 🛠️ Utilitários Básicos

```BASH
# Informações do sistema
uname -a          # Detalhes do kernel
lsb_release -a    # Versão da distribuição
hostnamectl       # Informações do host

# Recursos
top               # Monitor de processos
htop              # Monitor interativo
df -h             # Uso de disco
free -h           # Uso de memória
```

### 📊 Monitoramento

```BASH
# Logs do sistema
journalctl       # Logs do systemd
dmesg            # Mensagens do kernel
tail -f /var/log/syslog  # Log em tempo real
```

## Boas Práticas

1. Documentação

* Mantenha registros de alterações

* Documente procedimentos

* Crie guias de recuperação

2. Backup

* Realize backups regulares

* Teste procedimentos de restauração

* Mantenha cópias offsite

3. Segurança

* Atualize o sistema regularmente

* Monitore logs de segurança

* Implemente política de senhas

4. Automação

* Automatize tarefas rotineiras

* Use scripts para padronização

* Implemente monitoramento automático

## Próximos Passos

* [Gerenciamento de Usuários](user-management.html)

* [Controle de Processos](process-control.html)

* [Monitoramento do Sistema](system-monitoring.html)

* [Administração de Rede](network-admin.html)

Tip:

"Um bom administrador de sistemas é aquele que automatiza a si mesmo para fora do trabalho."



# Gerenciamento de Usuários 👥

## Comandos Básicos

### 👤 Usuários

```BASH
# Criar e modificar usuários
useradd -m -s /bin/bash usuario  # Cria usuário
usermod -aG grupo usuario        # Adiciona a grupo
passwd usuario                   # Define senha
userdel -r usuario              # Remove usuário

# Informações
id usuario                      # Info do usuário
who                            # Usuários logados
w                              # Quem está fazendo o quê
last                           # Histórico de login
```

### 👥 Grupos

```BASH
# Gerenciamento de grupos
groupadd grupo                 # Cria grupo
groupmod -n novo_nome grupo    # Renomeia
groupdel grupo                 # Remove grupo
gpasswd -a usuario grupo      # Adiciona ao grupo
```

## Permissões e Segurança

### 🔐 Controle de Acesso

```BASH
# Permissões básicas
chmod 755 arquivo              # Define permissões
chown usuario:grupo arquivo    # Muda proprietário
chgrp grupo arquivo           # Muda grupo

# ACLs
setfacl -m u:usuario:rw arquivo  # Define ACL
getfacl arquivo                  # Lista ACLs
```

### 🛡️ Sudo e Privilégios

```BASH
# Configuração sudo
visudo                        # Edita sudoers
sudo -l                       # Lista permissões
sudo -u usuario comando       # Executa como usuário
```

## Exercícios Práticos

### 🎯 Missão 1: Gestão Básica

```BASH
#!/bin/bash
# setup_user.sh

# Cria usuário com ambiente básico
setup_user() {
    local usuario=$1
    local grupo=$2

    # Cria usuário
    useradd -m -s /bin/bash "$usuario"
    
    # Define grupo primário
    usermod -g "$grupo" "$usuario"
    
    # Configura ambiente
    cp /etc/skel/.* "/home/$usuario/"
    chown -R "$usuario:$grupo" "/home/$usuario"
}
```

### 🎯 Missão 2: Auditoria

```BASH
#!/bin/bash
# audit_users.sh

# Auditoria de usuários
audit_users() {
    echo "=== Usuários do Sistema ==="
    awk -F: '$3 >= 1000 && $3 != 65534 {print $1}' /etc/passwd
    
    echo -e "\n=== Grupos ==="
    for user in $(awk -F: '$3 >= 1000 && $3 != 65534 {print $1}' /etc/passwd); do
        echo -n "$user: "
        groups "$user"
    done
}
```

## Troubleshooting

### 🔧 Problemas Comuns

* Senha esquecida: Use `passwd` como root

* Grupos incorretos: Verifique com `groups` e `id`

* Permissões: Use `ls -l` e `namei -l`

* Sudo: Verifique `/var/log/auth.log`

Tip:

"Com grandes privilégios vêm grandes responsabilidades."



# Controle de Processos

Note:

Este tópico aborda o gerenciamento e controle de processos no Linux, incluindo monitoramento, manipulação e otimização.

## Comandos Básicos

### 🔍 Visualização de Processos

```BASH
# Listar processos
ps aux                # Lista detalhada
ps -ef               # Formato alternativo
ps -u $USER          # Processos do usuário
top                  # Monitor em tempo real
htop                 # Versão melhorada do top
```

### 🎮 Controle de Processos

```BASH
# Sinais básicos
kill PID             # Encerra processo (SIGTERM)
kill -9 PID          # Força encerramento (SIGKILL)
killall processo     # Encerra por nome
pkill processo       # Variação do killall

# Controle de jobs
ctrl+z               # Suspende processo
bg                   # Executa em background
fg                   # Traz para foreground
jobs                 # Lista jobs ativos
```

## Monitoramento Avançado

### 📊 Recursos do Sistema

```BASH
# Memória e CPU
free -h              # Uso de memória
vmstat 1             # Estatísticas de VM
mpstat 1             # Estatísticas CPU
iostat               # E/S e CPU

# Monitoramento em tempo real
watch -n 1 'ps aux --sort=-%cpu | head'  # Top processos CPU
watch -n 1 'ps aux --sort=-%mem | head'  # Top processos memória
```

### ⚡ Prioridade e Recursos

```BASH
# Ajuste de prioridade
nice -n 10 comando           # Inicia com prioridade menor
renice -n 10 -p PID         # Ajusta prioridade
renice -n 10 -u usuario     # Ajusta para usuário

# Limites de recursos
ulimit -n 2048              # Limite de arquivos
ulimit -u 100              # Limite de processos
ulimit -a                  # Mostra todos limites
```

## Scripts de Automação

### 🤖 Monitor de Processos

```BASH
#!/bin/bash
# process_monitor.sh

monitor_process() {
    local processo="$1"
    local max_cpu="$2"
    local max_mem="$3"
    
    while true; do
        # Obtém uso de CPU e memória
        cpu=$(ps -p $(pgrep "$processo") -o %cpu= 2>/dev/null)
        mem=$(ps -p $(pgrep "$processo") -o %mem= 2>/dev/null)
        
        # Verifica limites
        if (( $(echo "$cpu > $max_cpu" | bc -l) )); then
            echo "ALERTA: $processo usando muita CPU ($cpu%)"
        fi
        
        if (( $(echo "$mem > $max_mem" | bc -l) )); then
            echo "ALERTA: $processo usando muita memória ($mem%)"
        fi
        
        sleep 60
    done
}
```

### 🔄 Reinício Automático

```BASH
#!/bin/bash
# auto_restart.sh

watch_and_restart() {
    local processo="$1"
    local max_restarts=3
    local count=0
    
    while true; do
        if ! pgrep -x "$processo" > /dev/null; then
            if [ $count -lt $max_restarts ]; then
                echo "Reiniciando $processo..."
                systemctl restart "$processo"
                ((count++))
            else
                echo "Limite de reinícios atingido para $processo"
                break
            fi
        fi
        sleep 30
    done
}
```

## Técnicas Avançadas

### 🔍 Diagnóstico

```BASH
# Análise de processos
strace -p PID        # Trace de syscalls
lsof -p PID         # Arquivos abertos
pmap PID            # Mapa de memória

# Análise de performance
perf top            # Análise CPU
perf record         # Grava dados
perf report         # Analisa dados
```

### 🔒 Isolamento

```BASH
# Controle de recursos com cgroups
cgcreate -g cpu,memory:grupo1
cgset -r cpu.shares=512 grupo1
cgexec -g cpu,memory:grupo1 comando
```

## Troubleshooting

### 🔧 Problemas Comuns

* Processo Zumbi: Use `ps aux | grep Z`

* Alto Consumo: Identifique com `top` ou `htop`

* Travamento: Verifique logs com `dmesg`

* Memória: Analise com `free` e `vmstat`

Tip:

"Um processo bem controlado é um sistema estável."



# Monitoramento de Sistema: Vigilância Contínua 🔍

## Ferramentas Essenciais

### 📊 Monitoramento em Tempo Real

```BASH
# Monitoramento básico
top         # Visão geral do sistema
htop        # Interface interativa
atop        # Histórico de processos
iotop       # Monitoramento de I/O
```

### 📈 Análise de Recursos

```BASH
# CPU e Memória
vmstat 1    # Estatísticas de VM
free -h     # Uso de memória
mpstat -P ALL  # Estatísticas por CPU
sar -u 1 5    # Utilização de CPU
```

## Scripts de Monitoramento

### 🔄 Monitor de Recursos

```BASH
#!/bin/bash
# resource_monitor.sh

monitor_resources() {
    while true; do
        printf "\n=== %s ===\n" "$(date)"
        
        echo "CPU Usage:"
        top -bn1 | head -n 3
        
        echo -e "\nMemory Usage:"
        free -h
        
        echo -e "\nDisk Usage:"
        df -h
        
        sleep 60
    done
}
```

### 🚨 Sistema de Alertas

```BASH
#!/bin/bash
# alert_system.sh

check_threshold() {
    local metric="$1"
    local threshold="$2"
    local current="$3"
    
    if (( $(echo "$current > $threshold" | bc -l) )); then
        send_alert "$metric" "$current" "$threshold"
    fi
}

monitor_with_alerts() {
    # CPU threshold (80%)
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')
    check_threshold "CPU" 80 "$cpu_usage"
    
    # Memory threshold (90%)
    mem_usage=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
    check_threshold "Memory" 90 "$mem_usage"
    
    # Disk threshold (85%)
    disk_usage=$(df -h / | tail -1 | awk '{print $5}' | tr -d '%')
    check_threshold "Disk" 85 "$disk_usage"
}
```

## Logging e Análise

### 📝 Sistema de Logs

```BASH
#!/bin/bash
# system_logger.sh

log_system_stats() {
    local log_file="/var/log/system_stats.log"
    local date_format="+%Y-%m-%d %H:%M:%S"
    
    while true; do
        {
            echo "=== $(date "$date_format") ==="
            echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
            echo "CPU Usage: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')"
            echo "Memory Free: $(free -h | grep Mem | awk '{print $4}')"
            echo "Disk Usage: $(df -h / | tail -1 | awk '{print $5}')"
            echo "---"
        } >> "$log_file"
        
        sleep 300
    done
}
```

### 📊 Análise de Logs

```BASH
#!/bin/bash
# log_analyzer.sh

analyze_logs() {
    local log_file="$1"
    local start_date="$2"
    local end_date="$3"
    
    echo "=== Análise de Logs ==="
    echo "Período: $start_date até $end_date"
    
    # CPU médio
    echo -n "CPU Médio: "
    awk '/CPU Usage:/ {sum+=$3; count++} 
         END {print sum/count "%"}' "$log_file"
    
    # Picos de memória
    echo "Picos de Memória:"
    grep "Memory Free:" "$log_file" | sort -k4 -h | head -5
    
    # Tendência de disco
    echo "Tendência de Uso de Disco:"
    grep "Disk Usage:" "$log_file" | 
        awk '{print $3}' | 
        sort -n | 
        uniq -c
}
```

## Visualização de Dados

### 📈 Geração de Gráficos

```BASH
#!/bin/bash
# graph_generator.sh

generate_graphs() {
    local data_file="$1"
    local output_dir="$2"
    
    # Requer gnuplot
    gnuplot <<EOF
    set terminal png
    set output "$output_dir/cpu_usage.png"
    set title "CPU Usage Over Time"
    set xlabel "Time"
    set ylabel "Usage %"
    plot "$data_file" using 1:2 with lines
EOF
}
```

## Exercícios Práticos

### 🎯 Missão 1: Monitor Completo

```BASH
# Desenvolva um sistema que:
# 1. Monitore todos recursos críticos
# 2. Gere alertas configuráveis
# 3. Mantenha histórico de métricas
# 4. Gere relatórios periódicos
```

### 🎯 Missão 2: Análise Preditiva

```BASH
# Crie um sistema que:
# 1. Identifique padrões de uso
# 2. Preveja possíveis problemas
# 3. Sugira otimizações
# 4. Gere relatórios de tendências
```

## Próximos Passos

1. [Performance Tuning](null)

2. [Capacity Planning](null)

3. [Automation Strategies](null)

Tip:

"Monitorar é prever. Prever é prevenir."

```
MONITORAMENTO
[📊📊📊📊📊] 100%
STATUS: ATIVO
SISTEMA: MONITORADO
```



# Administração de Rede 🌐

## Configuração Básica

### 📡 Interface de Rede

```BASH
# Informações
ip addr show               # Lista interfaces
ip link set eth0 up       # Ativa interface
ip link set eth0 down     # Desativa interface

# Configuração
ip addr add 192.168.1.10/24 dev eth0  # Define IP
ip route add default via 192.168.1.1   # Gateway
```

### 🔌 Conectividade

```BASH
# Testes básicos
ping -c 4 8.8.8.8        # Teste ICMP
traceroute google.com    # Rota até destino
mtr google.com           # Análise de rota
dig google.com           # Consulta DNS
```

## Monitoramento

### 📊 Análise de Tráfego

```BASH
# Ferramentas de monitoramento
tcpdump -i eth0          # Captura pacotes
netstat -tuln            # Portas abertas
ss -tuln                 # Alternativa moderna
iftop                    # Monitor de banda
```

### 🔍 Diagnóstico

```BASH
# Ferramentas de diagnóstico
nmap -sP 192.168.1.0/24  # Scan de rede
nc -zv host 80           # Teste de porta
curl -I website.com      # Cabeçalhos HTTP
wget -qO- website.com    # Download teste
```

## Segurança

### 🛡️ Firewall

```BASH
# Configuração básica de iptables
iptables -L              # Lista regras
iptables -A INPUT -p tcp --dport 80 -j ACCEPT  # Libera porta
iptables -P INPUT DROP   # Política padrão
iptables-save           # Salva regras
```

### 🔐 SSL/TLS

```BASH
# Certificados
openssl req -new -x509 -nodes -out cert.pem -keyout key.pem
openssl x509 -in cert.pem -text  # Verifica certificado
```

## Exercícios Práticos

### 🎯 Missão 1: Monitor de Rede

```BASH
#!/bin/bash
# network_monitor.sh

monitor_network() {
    while true; do
        echo "=== $(date) ==="
        
        # Verifica conectividade
        ping -c 1 8.8.8.8 >/dev/null && 
            echo "Internet: OK" ||
            echo "Internet: FALHA"
        
        # Estatísticas de interface
        ip -s link show eth0
        
        # Conexões ativas
        ss -tuln
        
        sleep 300
    done
}
```

### 🎯 Missão 2: Segurança

```BASH
#!/bin/bash
# secure_network.sh

secure_ports() {
    # Limpa regras existentes
    iptables -F
    
    # Política padrão
    iptables -P INPUT DROP
    iptables -P FORWARD DROP
    iptables -P OUTPUT ACCEPT
    
    # Permite conexões estabelecidas
    iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # Permite serviços específicos
    iptables -A INPUT -p tcp --dport 22 -j ACCEPT  # SSH
    iptables -A INPUT -p tcp --dport 80 -j ACCEPT  # HTTP
    iptables -A INPUT -p tcp --dport 443 -j ACCEPT # HTTPS
}
```

## Troubleshooting

### 🔧 Problemas Comuns

* Sem conexão: Verifique cabo e interface

* DNS lento: Use `dig` e verifique `/etc/resolv.conf`

* Perda de pacotes: Analise com `mtr`

* Portas bloqueadas: Verifique firewall

Tip:

"A rede é confiável até provar o contrário."



# Referências e Recursos 📚

```
CARREGANDO BIBLIOTECA DE CONHECIMENTO...
=======================================
STATUS: RECURSOS COMPILADOS
PODER: MÁXIMO
CONHECIMENTO: INFINITO
=======================================
```

## Visão Geral

Esta seção contém recursos essenciais para sua jornada no Bash, incluindo:

* Referência rápida de comandos

* Templates prontos para scripts

* Melhores práticas e padrões

## Recursos Disponíveis

### 

[Referência de Comandos](command-reference.html)

* Catálogo completo de comandos

* Exemplos práticos

* Casos de uso comuns

### 

[Templates de Scripts](script-templates.html)

* Scripts prontos para uso

* Estruturas básicas

* Padrões reutilizáveis

### 

[Melhores Práticas](best-practices.html)

* Guias de estilo

* Padrões de código

* Dicas de segurança

## Recursos Externos

### 📚 Documentação Oficial

* [GNU Bash Manual](https://www.gnu.org/software/bash/manual/)

* [Linux Documentation Project](https://tldp.org/)

* [Bash Hackers Wiki](https://wiki.bash-hackers.org/)

### 🎓 Tutoriais e Cursos

* [Shell Scripting Tutorial](https://www.shellscript.sh/)

* [Bash Academy](https://guide.bash.academy/)

* [Linux Command Line Basics](https://ubuntu.com/tutorials/command-line-for-beginners)

### 🛠️ Ferramentas

* [ShellCheck](https://www.shellcheck.net/)

* [Explainshell](https://explainshell.com/)

* [Bash Debugger](http://bashdb.sourceforge.net/)

Tip:

"O conhecimento é poder. Bash é superpower."



# Referência de Comandos 📖

## Comandos Essenciais

### Navegação

| Comando |Descrição |Exemplo |
-------------------------------
| `cd` |Muda diretório |`cd /home/user` |
| `pwd` |Mostra diretório atual |`pwd` |
| `ls` |Lista arquivos |`ls -la` |
| `find` |Busca arquivos |`find . -name "*.sh"` |

### Manipulação de Arquivos

| Comando |Descrição |Exemplo |
-------------------------------
| `cp` |Copia |`cp arquivo.txt backup/` |
| `mv` |Move/renomeia |`mv old.txt new.txt` |
| `rm` |Remove |`rm -rf diretorio/` |
| `chmod` |Muda permissões |`chmod +x script.sh` |

### Processamento de Texto

| Comando |Descrição |Exemplo |
-------------------------------
| `grep` |Busca texto |`grep -r "texto" .` |
| `sed` |Editor de stream |`sed 's/old/new/g'` |
| `awk` |Processamento |`awk '{print $1}'` |

### Sistema

| Comando |Descrição |Exemplo |
-------------------------------
| `ps` |Lista processos |`ps aux` |
| `top` |Monitor sistema |`top` |
| `df` |Espaço em disco |`df -h` |
| `du` |Uso de disco |`du -sh *` |

## Operadores e Sintaxe

### Redirecionamento

```BASH
comando > arquivo    # Saída para arquivo
comando >> arquivo   # Anexa ao arquivo
comando < arquivo    # Entrada do arquivo
comando 2> erro.log  # Redireciona erro
```

### Pipes e Concatenação

```BASH
cmd1 | cmd2         # Pipe
cmd1 && cmd2        # AND lógico
cmd1 || cmd2        # OR lógico
cmd1 ; cmd2         # Sequencial
```

### Expansões

```BASH
${variavel}         # Expansão variável
$(comando)          # Expansão comando
$((expressao))      # Expansão aritmética
{1..5}             # Expansão de sequência
```

## Referência Rápida por Categoria

### 🔍 Busca

```BASH
find / -name arquivo
locate arquivo
which comando
whereis comando
```

### 📊 Monitoramento

```BASH
free -h
vmstat
iostat
netstat
```

### 📝 Edição

```BASH
nano arquivo
vim arquivo
head arquivo
tail -f arquivo
```

### 🔒 Segurança

```BASH
sudo comando
chown usuario arquivo
chmod 755 arquivo
ssh usuario@host
```

## Flags Comuns

### Flags Universais

* `-h, --help`: Ajuda

* `-v, --version`: Versão

* `-f, --force`: Força

* `-r, --recursive`: Recursivo

### Flags de Listagem

* `-l`: Formato longo

* `-a`: Mostra ocultos

* `-h`: Tamanhos legíveis

* `-R`: Recursivo

## Atalhos do Terminal

### Navegação

* `Ctrl + A`: Início da linha

* `Ctrl + E`: Fim da linha

* `Ctrl + U`: Limpa linha

* `Ctrl + R`: Busca histórico

### Controle

* `Ctrl + C`: Cancela

* `Ctrl + Z`: Suspende

* `Ctrl + D`: EOF/Sair

* `Ctrl + L`: Limpa tela

Tip:

"Um comando vale mais que mil cliques."



# Templates de Scripts 📝

## Templates Básicos

### Script Base

```BASH
#!/bin/bash
#
# Nome: script_base.sh
# Descrição: Template básico para scripts Bash
# Autor: Seu Nome
# Data: YYYY-MM-DD

# Configurações
set -euo pipefail
IFS=$'\n\t'

# Variáveis
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${SCRIPT_DIR}/script.log"

# Funções
log() {
    local msg="[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    echo "$msg" | tee -a "$LOG_FILE"
}

cleanup() {
    log "Limpando recursos..."
    # Adicione código de limpeza aqui
}

# Tratamento de erros
trap cleanup EXIT
trap 'log "Erro na linha $LINENO. Comando: $BASH_COMMAND"' ERR

# Código principal
main() {
    log "Iniciando script..."
    # Seu código aqui
    log "Script finalizado."
}

main "$@"
```

### Script de Backup

```BASH
#!/bin/bash
#
# Nome: backup.sh
# Descrição: Template para script de backup

# Configurações
SOURCE_DIR="/caminho/origem"
BACKUP_DIR="/caminho/backup"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="backup_${DATE}.tar.gz"

# Criar backup
backup() {
    tar -czf "${BACKUP_DIR}/${BACKUP_FILE}" "$SOURCE_DIR"
}

# Limpar backups antigos
cleanup_old() {
    find "$BACKUP_DIR" -name "backup_*.tar.gz" -mtime +7 -delete
}

# Executar
backup
cleanup_old
```

### Script de Monitoramento

```BASH
#!/bin/bash
#
# Nome: monitor.sh
# Descrição: Template para monitoramento

# Configurações
THRESHOLD_CPU=80
THRESHOLD_MEM=90
LOG_FILE="/var/log/monitor.log"

# Funções de monitoramento
check_cpu() {
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d. -f1)
    if [ "$cpu_usage" -gt "$THRESHOLD_CPU" ]; then
        echo "ALERTA: CPU em $cpu_usage%"
    fi
}

check_memory() {
    mem_usage=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
    if [ "${mem_usage%.*}" -gt "$THRESHOLD_MEM" ]; then
        echo "ALERTA: Memória em $mem_usage%"
    fi
}

# Loop principal
while true; do
    check_cpu
    check_memory
    sleep 60
done
```

## Templates Avançados

### API Client

```BASH
#!/bin/bash
#
# Nome: api_client.sh
# Descrição: Template para cliente API

# Configurações
API_URL="https://api.exemplo.com"
API_TOKEN="seu_token"

# Funções API
api_get() {
    local endpoint="$1"
    curl -s -H "Authorization: Bearer $API_TOKEN" \
         "${API_URL}${endpoint}"
}

api_post() {
    local endpoint="$1"
    local data="$2"
    curl -s -X POST \
         -H "Authorization: Bearer $API_TOKEN" \
         -H "Content-Type: application/json" \
         -d "$data" \
         "${API_URL}${endpoint}"
}

# Uso
response=$(api_get "/users")
echo "$response" | jq '.'
```

### Parser de Logs

```BASH
#!/bin/bash
#
# Nome: log_parser.sh
# Descrição: Template para análise de logs

# Configurações
LOG_FILE="/var/log/app.log"
PATTERN='ERROR|WARN'
OUTPUT_FILE="analysis.txt"

# Funções de análise
analyze_logs() {
    echo "=== Análise de Logs ===" > "$OUTPUT_FILE"
    echo "Data: $(date)" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    
    echo "Erros encontrados:" >> "$OUTPUT_FILE"
    grep -E "$PATTERN" "$LOG_FILE" >> "$OUTPUT_FILE"
    
    echo "" >> "$OUTPUT_FILE"
    echo "Sumário:" >> "$OUTPUT_FILE"
    grep -E "$PATTERN" "$LOG_FILE" | awk '{print $1}' | sort | uniq -c >> "$OUTPUT_FILE"
}

# Executar
analyze_logs
```

### Gerenciador de Serviços

```BASH
#!/bin/bash
#
# Nome: service_manager.sh
# Descrição: Template para gerenciamento de serviços

# Configurações
SERVICES=("nginx" "mysql" "redis")
LOG_DIR="/var/log/services"

# Funções
check_service() {
    local service="$1"
    systemctl is-active "$service" >/dev/null 2>&1
}

restart_service() {
    local service="$1"
    systemctl restart "$service"
}

log_status() {
    local service="$1"
    local status="$2"
    echo "[$(date)] $service: $status" >> "${LOG_DIR}/status.log"
}

# Loop principal
for service in "${SERVICES[@]}"; do
    if ! check_service "$service"; then
        log_status "$service" "DOWN - Tentando reiniciar"
        restart_service "$service"
        sleep 5
        if check_service "$service"; then
            log_status "$service" "RECUPERADO"
        else
            log_status "$service" "FALHA NA RECUPERAÇÃO"
        fi
    else
        log_status "$service" "OK"
    fi
done
```

## Dicas de Uso

1. Personalização

* Ajuste variáveis e configurações

* Modifique funções conforme necessidade

* Adicione logs específicos

2. Boas Práticas

* Mantenha documentação atualizada

* Use funções para organizar código

* Implemente tratamento de erros

3. Segurança

* Valide entradas

* Use permissões adequadas

* Proteja dados sensíveis

Tip:

"Um bom template é meio caminho andado."



# Melhores Práticas

## Princípios Fundamentais

### 1. Segurança

```BASH
# ✅ Correto: Validar entradas
input="${1:-}"
if [[ ! "$input" =~ ^[0-9]+$ ]]; then
    echo "Erro: Digite apenas números"
    exit 1
fi

# ❌ Incorreto: Entrada sem validação
rm -rf "$1"
```

### 2. Legibilidade

```BASH
# ✅ Correto: Código legível e documentado
get_user_age() {
    local name="$1"
    local birth_year="$2"
    local current_year=$(date +%Y)
    
    echo $((current_year - birth_year))
}

# ❌ Incorreto: Código confuso
a() { echo $(($(date +%Y)-$2)); }
```

### 3. Manutenibilidade

```BASH
# ✅ Correto: Configurações centralizadas
readonly CONFIG_FILE="/etc/app/config.conf"
readonly LOG_DIR="/var/log/app"
readonly MAX_RETRIES=3

# ❌ Incorreto: Valores hardcoded
if [ $count -gt 3 ]; then
    echo "error" > /var/log/app/temp.log
fi
```

## Estrutura de Scripts

### 1. Cabeçalho Padrão

```BASH
#!/bin/bash
#
# Nome: script.sh
# Descrição: Breve descrição do script
# Autor: Seu Nome
# Data: YYYY-MM-DD
# Versão: 1.0
#
# Uso: ./script.sh [opções]
```

### 2. Organização do Código

```BASH
# Configurações
set -euo pipefail
IFS=$'\n\t'

# Variáveis globais
readonly VERSION="1.0.0"
readonly CONFIG_FILE="/etc/app/config.conf"

# Funções
function log_error() {
    local message="$1"
    echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $message" >&2
}

# Código principal
function main() {
    # Lógica principal aqui
}

# Execução
main "$@"
```

## Padrões de Codificação

### 1. Nomenclatura

```BASH
# ✅ Correto: Nomes descritivos
function validate_user_input() {
    local user_name="$1"
    local user_age="$2"
}

# ❌ Incorreto: Nomes obscuros
function val() {
    local n="$1"
    local a="$2"
}
```

### 2. Indentação e Formatação

```BASH
# ✅ Correto: Indentação consistente
if [ "$condition" = true ]; then
    for item in "${items[@]}"; do
        process_item "$item"
    done
fi

# ❌ Incorreto: Indentação inconsistente
if [ "$condition" = true ]; then
for item in "${items[@]}"
do
process_item "$item"
done
fi
```

## Tratamento de Erros

### 1. Validação de Entrada

```BASH
# ✅ Correto: Validação completa
function process_file() {
    local file="$1"
    
    if [ -z "$file" ]; then
        log_error "Nome do arquivo não fornecido"
        return 1
    fi
    
    if [ ! -f "$file" ]; then
        log_error "Arquivo não existe: $file"
        return 1
    fi
    
    if [ ! -r "$file" ]; then
        log_error "Arquivo sem permissão de leitura: $file"
        return 1
    fi
}
```

### 2. Tratamento de Exceções

```BASH
# ✅ Correto: Tratamento de erros
set -e
trap 'echo "Erro na linha $LINENO"' ERR

function cleanup() {
    # Limpeza de recursos
    rm -f "$TEMP_FILE"
}

trap cleanup EXIT
```

## Otimização e Performance

### 1. Uso de Recursos

```BASH
# ✅ Correto: Uso eficiente
while IFS= read -r line; do
    process_line "$line"
done < "$file"

# ❌ Incorreto: Desperdício de recursos
cat "$file" | while read line; do
    process_line "$line"
done
```

### 2. Operações em Lote

```BASH
# ✅ Correto: Operações em lote
find . -type f -name "*.log" -exec rm {} +

# ❌ Incorreto: Operações individuais
for file in *.log; do
    rm "$file"
done
```

## Segurança Avançada

### 1. Permissões

```BASH
# ✅ Correto: Gestão de permissões
umask 077
touch "$SENSITIVE_FILE"
chmod 600 "$SENSITIVE_FILE"

# ❌ Incorreto: Permissões inseguras
touch "$SENSITIVE_FILE"
chmod 777 "$SENSITIVE_FILE"
```

### 2. Dados Sensíveis

```BASH
# ✅ Correto: Proteção de dados sensíveis
read -s -p "Password: " password
echo

# ❌ Incorreto: Exposição de dados
echo "Password: $password"
```

## Documentação

### 1. Comentários

```BASH
# ✅ Correto: Comentários úteis
# Valida o formato do CPF (XXX.XXX.XXX-XX)
function validate_cpf() {
```



# Apêndices 📚

Bem-vindo à seção de apêndices do Learn Bash! Aqui você encontrará informações complementares e recursos essenciais para sua jornada no mundo do Bash.

## O que você encontrará aqui

### 

[Instalação](installation.html)

Guia completo para instalar e configurar seu ambiente Bash em diferentes sistemas operacionais.

### 

[Configuração](configuration.html)

Aprenda a personalizar e otimizar seu ambiente Bash para máxima produtividade.

### 

[Troubleshooting](troubleshooting.html)

Soluções para problemas comuns e guia de resolução de problemas.

### 

[Glossário](glossary.html)

Dicionário de termos técnicos e conceitos importantes do Bash.

## Como usar esta seção

* Use como referência rápida

* Consulte quando encontrar problemas

* Aprofunde seu conhecimento em tópicos específicos

* Mantenha como guia de consulta

## Dicas de navegação

* Cada subseção é independente

* Use os links para navegar entre tópicos relacionados

* Marque páginas importantes para referência futura

* Consulte o glossário sempre que encontrar termos desconhecidos

Tip:

"O conhecimento é poder, e estes apêndices são seu arsenal de recursos."



# Instalação do Bash 🛠️

## Windows

### Usando WSL (Windows Subsystem for Linux)

1. Abra o PowerShell como administrador

2. Execute:

```BASH
wsl --install
```

3. Reinicie o computador

4. O Ubuntu será instalado automaticamente com Bash

### Usando Git Bash

1. Baixe o Git para Windows em https://git-scm.com/download/win

2. Durante a instalação, mantenha as opções padrão

3. Git Bash será instalado com recursos Bash essenciais

## macOS

O Bash já vem instalado, mas você pode atualizar:

```BASH
# Usando Homebrew
brew install bash

# Tornar o novo Bash padrão
echo "/usr/local/bin/bash" | sudo tee -a /etc/shells
chsh -s /usr/local/bin/bash
```

## Linux

O Bash geralmente já vem instalado. Para garantir a última versão:

### Ubuntu/Debian

```BASH
sudo apt update
sudo apt install bash
```

### Fedora/RHEL

```BASH
sudo dnf update
sudo dnf install bash
```

## Verificação da Instalação

```BASH
# Verificar versão do Bash
bash --version

# Verificar shell padrão
echo $SHELL
```



# Configuração do Bash ⚙️

## Arquivos de Configuração

### 

`.bashrc`

Principal arquivo de configuração para shells interativos:

```BASH
# Exemplo de .bashrc
# Cores no prompt
export PS1="\[\033[32m\]\u@\h\[\033[00m\]:\[\033[34m\]\w\[\033[00m\]\$ "

# Aliases úteis
alias ll='ls -la'
alias update='sudo apt update && sudo apt upgrade'
alias gh='history | grep'

# Variáveis de ambiente
export PATH="$HOME/bin:$PATH"
export EDITOR="vim"
```

### 

`.bash_profile`

Para configuração de login:

```BASH
# Carrega .bashrc
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi

# Configurações específicas de login
export LANG=pt_BR.UTF-8
```

## Personalização

### Prompt (PS1)

```BASH
# Prompt simples com cores
PS1='\[\e[1;32m\]\u@\h\[\e[0m\]:\[\e[1;34m\]\w\[\e[0m\]\$ '

# Prompt informativo
PS1='\D{%F %T} \u@\h:\w\$ '
```

### Aliases Essenciais

```BASH
# Navegação
alias ..='cd ..'
alias ...='cd ../..'

# Segurança
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Utilitários
alias mkdir='mkdir -p'
alias ports='netstat -tulanp'
```

## Variáveis de Ambiente

```BASH
# História
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups

# Localização
export LANG=pt_BR.UTF-8
export LC_ALL=pt_BR.UTF-8

# Editores
export EDITOR=vim
export VISUAL=code
```



# Troubleshooting

Note:

Este módulo apresenta soluções para problemas comuns e técnicas de diagnóstico.

## Problemas Comuns

### Permissões

#### Problema: "Permission denied"

```BASH
# Solução 1: Verificar permissões
ls -l arquivo
chmod u+x arquivo

# Solução 2: Executar como sudo
sudo ./script.sh
```

### Variáveis de Ambiente

#### Problema: "Command not found"

```BASH
# Verificar PATH
echo $PATH

# Adicionar ao PATH
export PATH="$HOME/bin:$PATH"
```

### Scripts

#### Problema: "Bad interpreter"

```BASH
# Verificar shebang
head -n 1 script.sh

# Corrigir formato de linha
dos2unix script.sh
```

## Ferramentas de Diagnóstico

### Logs

```BASH
# Visualizar logs do sistema
tail -f /var/log/syslog

# Logs do Bash
history
```

### Debug

```BASH
# Modo verbose
bash -v script.sh

# Modo debug
bash -x script.sh

# Debug em seção específica
set -x  # inicia debug
comandos
set +x  # termina debug
```

## Checklist de Verificação

1. Permissões corretas?

2. Variáveis de ambiente configuradas?

3. Dependências instaladas?

4. Formato de arquivo correto?

5. Logs de erro verificados?



# Glossário 📖

## A

### Alias

Atalho para um comando ou série de comandos.

```BASH
alias ll='ls -la'
```

### Argumento

Valor passado para um comando ou script.

```BASH
cp arquivo1.txt arquivo2.txt  # arquivo1.txt e arquivo2.txt são argumentos
```

## B

### Bash

Bourne Again Shell - interpretador de comandos padrão em muitos sistemas Unix-like.

### Built-in

Comando interno do Bash, não um programa separado.

```BASH
cd, pwd, echo  # exemplos de built-ins
```

## E

### Environment Variable

Variável que afeta o comportamento do shell e programas.

```BASH
$PATH, $HOME, $USER  # exemplos de variáveis de ambiente
```

### Exit Code

Valor retornado por um comando indicando sucesso (0) ou erro (não-0).

```BASH
echo $?  # mostra o último exit code
```

## P

### Pipeline

Conexão da saída de um comando com a entrada de outro.

```BASH
comando1 | comando2
```

### Prompt

Indicador de que o shell está pronto para receber comandos.

```BASH
$  # prompt padrão para usuários normais
#  # prompt padrão para root
```

## S

### Shell Script

Arquivo contendo comandos Bash para execução.

```BASH
#!/bin/bash  # shebang indica que é um script Bash
```

### Shebang

Primeira linha de um script indicando o interpretador.

```BASH
#!/bin/bash
#!/usr/bin/env python3
```

## W

### Wildcard

Caractere especial para matching de padrões.

```BASH
*.txt  # match qualquer arquivo .txt
```



# Exercícios e Projetos 💪

Bem-vindo à seção prática do Learn Bash! Aqui você encontrará exercícios e projetos para consolidar seu aprendizado.

## Estrutura dos Exercícios

### 

[Exercícios Básicos](basic-exercises.html)

* Fundamentos do Bash

* Comandos essenciais

* Navegação básica

* Manipulação de arquivos

### 

[Exercícios Intermediários](intermediate-exercises.html)

* Scripts simples

* Processamento de texto

* Automação básica

* Controle de fluxo

### 

[Exercícios Avançados](advanced-exercises.html)

* Scripts complexos

* Automação avançada

* Integração de sistemas

* Debugging

### 

[Projetos Práticos](projects.html)

* Projetos do mundo real

* Aplicações práticas

* Desafios completos

## Como Praticar

1. Comece pelos exercícios básicos

2. Avance gradualmente

3. Tente resolver sozinho primeiro

4. Consulte as soluções apenas após tentar

5. Pratique regularmente

Tip:

"A prática leva à perfeição. Continue codando!" 🚀



# Exercícios Básicos 🎯

## Navegação no Sistema de Arquivos

### Exercício 1: Exploração Básica

1. Crie uma pasta chamada `pratica_bash`

2. Navegue até ela

3. Crie três subpastas: `docs`, `scripts`, `backup`

4. Liste o conteúdo do diretório

5. Volte para o diretório pai

### Exercício 2: Manipulação de Arquivos

1. Crie um arquivo `notas.txt`

2. Adicione algumas linhas de texto

3. Copie para `backup/notas_backup.txt`

4. Compare os dois arquivos

## Comandos Básicos

### Exercício 3: Trabalho com Texto

1. Use `echo` para criar um arquivo

2. Conte as linhas com `wc`

3. Visualize com `cat` e `less`

4. Busque palavras com `grep`

### Exercício 4: Permissões

1. Crie um script simples

2. Torne-o executável

3. Execute o script

4. Verifique as permissões

## Soluções

### Exercício 1

```BASH
mkdir pratica_bash
cd pratica_bash
mkdir docs scripts backup
ls
cd ..
```

### Exercício 2

```BASH
echo "Linha 1" > notas.txt
echo "Linha 2" >> notas.txt
cp notas.txt backup/notas_backup.txt
diff notas.txt backup/notas_backup.txt
```

### Exercício 3

```BASH
echo "Testando" > teste.txt
echo "Mais uma linha" >> teste.txt
wc -l teste.txt
cat teste.txt
grep "linha" teste.txt
```

### Exercício 4

```BASH
echo '#!/bin/bash' > script.sh
echo 'echo "Olá, Mundo!"' >> script.sh
chmod +x script.sh
./script.sh
ls -l script.sh
```



# Exercícios Intermediários 🚀

## Scripts e Automação

### Exercício 1: Backup Automatizado

Crie um script que:

1. Aceite um diretório como argumento

2. Crie um backup com data/hora

3. Comprima o backup

4. Liste os backups existentes

```BASH
#!/bin/bash
# backup.sh
dir=$1
date=$(date +%Y%m%d_%H%M%S)
tar -czf "backup_${date}.tar.gz" "$dir"
ls -l backup_*.tar.gz
```

### Exercício 2: Monitor de Sistema

Crie um script que mostre:

1. Uso de CPU

2. Memória disponível

3. Espaço em disco

4. Processos ativos

```BASH
#!/bin/bash
# monitor.sh
echo "=== Sistema ==="
top -bn1 | head -n 3
echo "=== Memória ==="
free -h
echo "=== Disco ==="
df -h
echo "=== Processos ==="
ps aux | head -n 5
```

## Processamento de Texto

### Exercício 3: Análise de Logs

1. Processe um arquivo de log

2. Conte ocorrências de erros

3. Extraia timestamps

4. Gere relatório

### Exercício 4: Manipulação de CSV

1. Leia um arquivo CSV

2. Filtre colunas específicas

3. Calcule totais

4. Gere novo CSV

## Soluções Disponíveis no Repositório

Tip:

Tente resolver os exercícios antes de consultar as soluções!
Para soluções completas, visite: `github.com/learn-bash/solutions`



# Exercícios Avançados 🔥

## Automação Avançada

### Exercício 1: Deploy Automatizado

Crie um script que:

1. Clone um repositório Git

2. Execute testes

3. Faça build

4. Deploy para servidor

```BASH
#!/bin/bash
# deploy.sh
repo=$1
branch=$2

git clone "$repo"
cd "$(basename "$repo" .git)"
git checkout "$branch"

# Executar testes
if ! make test; then
    echo "Testes falharam!"
    exit 1
fi

# Build e deploy
make build
rsync -avz dist/ user@server:/var/www/
```

### Exercício 2: Monitor de Rede

Desenvolva um script que:

1. Monitore conexões de rede

2. Alerte sobre problemas

3. Registre estatísticas

4. Gere relatórios

## Integração de Sistemas

### Exercício 3: API Integration

Crie um script que:

1. Faça requisições REST

2. Processe JSON

3. Armazene resultados

4. Gere relatórios

```BASH
#!/bin/bash
# api_monitor.sh
api_url="https://api.exemplo.com"
token="seu_token"

response=$(curl -s -H "Authorization: Bearer $token" "$api_url/status")
echo "$response" | jq '.status'
```

### Exercício 4: Cluster Management

Desenvolva scripts para:

1. Gerenciar múltiplos servidores

2. Sincronizar configurações

3. Monitorar recursos

4. Balancear carga

## Desafios Extra

### Challenge 1: Security Audit

Crie uma ferramenta que:

* Analise logs de segurança

* Detecte padrões suspeitos

* Gere alertas

* Tome ações automáticas

### Challenge 2: Database Backup

Implemente um sistema que:

* Faça backup de diferentes DBs

* Valide integridade

* Rotacione backups antigos

* Notifique status

Tip:

Estes exercícios requerem conhecimento avançado de Bash e sistemas Unix.
Consulte a documentação e pratique em ambiente de teste!



# Projetos Práticos 🛠️

## Projeto 1: Sistema de Backup

### Descrição

Desenvolva um sistema completo de backup com:

* Interface de linha de comando

* Backup incremental

* Compressão e criptografia

* Logs e notificações

### Requisitos

1. Configuração via arquivo YAML

2. Suporte a múltiplos destinos

3. Rotação de backups

4. Relatórios de status

## Projeto 2: Monitor de Servidor

### Descrição

Crie um dashboard para monitoramento com:

* Métricas em tempo real

* Alertas configuráveis

* Interface web simples

* Histórico de eventos

### Componentes

1. Script de coleta de dados

2. Sistema de alertas

3. API REST simples

4. Frontend básico

## Projeto 3: Automatização DevOps

### Descrição

Desenvolva um conjunto de scripts para:

* CI/CD pipeline

* Gestão de ambientes

* Deploy automatizado

* Testes de integração

### Funcionalidades

1. Integração com Git

2. Testes automatizados

3. Deploy em múltiplos ambientes

4. Rollback automático

## Projeto 4: Gerenciador de Logs

### Descrição

Crie um sistema de análise de logs:

* Coleta centralizada

* Parsing inteligente

* Alertas de eventos

* Dashboard de análise

### Features

1. Coleta distribuída

2. Análise em tempo real

3. Armazenamento eficiente

4. Relatórios personalizados

## Como Desenvolver

1. Planeje a arquitetura

2. Desenvolva incrementalmente

3. Teste cada componente

4. Documente o projeto

5. Compartilhe no GitHub

Tip:

Dica: Use estes projetos para construir seu portfólio!



# Sistema de Backup 💾

## Visão Geral

Sistema completo de backup com interface CLI, suporte a backup incremental, compressão, criptografia e notificações.

## Estrutura do Projeto

```BASH
backup-system/
├── src/
│   ├── main.sh
│   ├── backup.sh
│   ├── compress.sh
│   ├── encrypt.sh
│   └── notify.sh
├── config/
│   └── backup.yaml
├── logs/
└── README.md
```

## Implementação

### 1. Script Principal

```BASH
#!/bin/bash
# src/main.sh

source "$(dirname "$0")/backup.sh"
source "$(dirname "$0")/compress.sh"
source "$(dirname "$0")/encrypt.sh"
source "$(dirname "$0")/notify.sh"

main() {
    local config_file="$1"
    load_config "$config_file"
    perform_backup
    compress_files
    encrypt_backup
    send_notification
}

main "$@"
```

### 2. Configuração YAML

```YAML
# config/backup.yaml
backup:
  source_dirs:
    - /path/to/source1
    - /path/to/source2
  destination: /backup/destination
  retention: 7
  compression: gzip
  encryption: gpg
  notify:
    email: admin@example.com
```

## Como Usar

1. Clone o repositório

2. Configure `backup.yaml`

3. Execute:

```BASH
./src/main.sh config/backup.yaml
```

## Recursos Avançados

* Backup incremental usando `rsync`

* Compressão com diferentes algoritmos

* Criptografia GPG

* Rotação automática de backups

* Sistema de logs detalhado

* Notificações por email/Slack



# Monitor de Servidor 📊

## Visão Geral

Dashboard de monitoramento com métricas em tempo real, alertas configuráveis e interface web.

## Arquitetura

```BASH
server-monitor/
├── backend/
│   ├── collector.sh
│   ├── api.py
│   └── alerts.sh
├── frontend/
│   ├── index.html
│   ├── css/
│   └── js/
├── config/
│   └── monitor.yaml
└── data/
```

## Implementação

### 1. Coletor de Métricas

```BASH
#!/bin/bash
# backend/collector.sh

collect_metrics() {
    # CPU
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')
    
    # Memory
    mem_info=$(free -m | grep Mem)
    mem_total=$(echo $mem_info | awk '{print $2}')
    mem_used=$(echo $mem_info | awk '{print $3}')
    
    # Disk
    disk_usage=$(df -h / | tail -1 | awk '{print $5}')
    
    # Save to JSON
    cat > data/metrics.json << EOF
{
    "timestamp": "$(date +%s)",
    "cpu": $cpu_usage,
    "memory": {
        "total": $mem_total,
        "used": $mem_used
    },
    "disk": "${disk_usage}"
}
EOF
}

while true; do
    collect_metrics
    sleep 60
done
```

### 2. API REST (Python/Flask)

```PYTHON
# backend/api.py
from flask import Flask, jsonify
import json

app = Flask(__name__)

@app.route('/api/metrics')
def get_metrics():
    with open('data/metrics.json') as f:
        return jsonify(json.load(f))

if __name__ == '__main__':
    app.run(port=5000)
```

### 3. Frontend

```HTML
<!-- frontend/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Server Monitor</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="dashboard">
        <div class="metric" id="cpu"></div>
        <div class="metric" id="memory"></div>
        <div class="metric" id="disk"></div>
    </div>
    <script src="js/dashboard.js"></script>
</body>
</html>
```

## Como Executar

1. Inicie o coletor:

```BASH
./backend/collector.sh &
```

1. Inicie a API:

```BASH
python backend/api.py
```

1. Abra `frontend/index.html` no navegador

## Recursos Adicionais

* Gráficos em tempo real com Chart.js

* Alertas configuráveis

* Histórico de métricas

* Exportação de relatórios



# Automatização DevOps 🔄

## Visão Geral

Suite de scripts para automação de CI/CD, gestão de ambientes e deploy.

## Estrutura

```BASH
devops-automation/
├── ci/
│   ├── pipeline.sh
│   └── tests.sh
├── cd/
│   ├── deploy.sh
│   └── rollback.sh
├── environments/
│   ├── dev.env
│   ├── staging.env
│   └── prod.env
└── scripts/
```

## Implementação

### 1. Pipeline CI

```BASH
#!/bin/bash
# ci/pipeline.sh

set -e

# Configuração
source "$(dirname "$0")/../environments/${ENV:-dev}.env"

# Etapas do Pipeline
run_tests() {
    echo "Running tests..."
    ./ci/tests.sh
}

build_app() {
    echo "Building application..."
    docker build -t myapp:${VERSION} .
}

push_image() {
    echo "Pushing to registry..."
    docker push myapp:${VERSION}
}

main() {
    run_tests
    build_app
    push_image
}

main "$@"
```

### 2. Deploy Automatizado

```BASH
#!/bin/bash
# cd/deploy.sh

set -e

# Configuração
source "$(dirname "$0")/../environments/${ENV:-dev}.env"

# Funções de Deploy
deploy_app() {
    echo "Deploying to ${ENV}..."
    
    # Backup atual
    backup_current_version
    
    # Deploy nova versão
    kubectl apply -f k8s/
    
    # Verificar health
    check_deployment_health
}

backup_current_version() {
    echo "Backing up current version..."
    kubectl get deployment -o yaml > backup/deploy-$(date +%Y%m%d_%H%M%S).yaml
}

check_deployment_health() {
    echo "Checking deployment health..."
    kubectl rollout status deployment/myapp
}

main() {
    deploy_app
}

main "$@"
```

## Configuração de Ambientes

```BASH
# environments/prod.env
export ENV="prod"
export VERSION="1.0.0"
export REGISTRY="registry.example.com"
export K8S_NAMESPACE="production"
```

## Como Usar

1. Configure o ambiente:

```BASH
source environments/dev.env
```

1. Execute o pipeline:

```BASH
./ci/pipeline.sh
```

1. Deploy:

```BASH
./cd/deploy.sh
```

## Recursos Avançados

* Integração com Git

* Testes automatizados

* Multi-ambiente

* Rollback automático

* Monitoramento de deploy



# Gerenciador de Logs 📝

## Visão Geral

Sistema de análise de logs com coleta centralizada, parsing inteligente e alertas.

## Estrutura

```BASH
log-manager/
├── collector/
│   ├── agent.sh
│   └── parser.sh
├── analyzer/
│   ├── analyze.sh
│   └── rules.yaml
├── storage/
│   └── database.sh
└── web/
    └── dashboard.php
```

## Implementação

### 1. Agente Coletor

```BASH
#!/bin/bash
# collector/agent.sh

# Configuração
LOG_DIRS=("/var/log/nginx" "/var/log/apache2" "/var/log/mysql")
CENTRAL_SERVER="logs.example.com"

collect_logs() {
    for dir in "${LOG_DIRS[@]}"; do
        find "$dir" -type f -name "*.log" -exec \
            ./parser.sh {} \; | \
            nc "$CENTRAL_SERVER" 514
    done
}

watch_logs() {
    inotifywait -m "${LOG_DIRS[@]}" -e modify |
    while read -r directory events filename; do
        if [[ "$filename" =~ \.log$ ]]; then
            ./parser.sh "$directory/$filename"
        fi
    done
}

main() {
    collect_logs
    watch_logs
}

main "$@"
```

### 2. Parser Inteligente

```BASH
#!/bin/bash
# collector/parser.sh

parse_log_line() {
    local line="$1"
    
    # Detectar formato
    if [[ "$line" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
        parse_standard_format "$line"
    elif [[ "$line" =~ ^\[[0-9]+\] ]]; then
        parse_bracketed_format "$line"
    else
        parse_custom_format "$line"
    fi
}

parse_standard_format() {
    awk '{
        timestamp=$1" "$2
        level=$3
        message=substr($0, index($0,$4))
        printf "{\"timestamp\":\"%s\",\"level\":\"%s\",\"message\":\"%s\"}\n",
            timestamp, level, message
    }'
}

while IFS= read -r line; do
    parse_log_line "$line"
done < "$1"
```

### 3. Análise em Tempo Real

```BASH
#!/bin/bash
# analyzer/analyze.sh

# Carregar regras
source "$(dirname "$0")/rules.yaml"

analyze_log() {
    while read -r log_entry; do
        # Parse JSON
        level=$(echo "$log_entry" | jq -r .level)
        message=$(echo "$log_entry" | jq -r .message)
        
        # Aplicar regras
        for rule in "${RULES[@]}"; do
            if [[ "$message" =~ ${rule[pattern]} ]]; then
                trigger_alert "${rule[name]}" "$message"
            fi
        done
    done
}

trigger_alert() {
    local rule_name="$1"
    local message="$2"
    
    # Enviar alerta
    curl -X POST "$ALERT_ENDPOINT" \
         -H "Content-Type: application/json" \
         -d "{
             \"rule\": \"$rule_name\",
             \"message\": \"$message\",
             \"timestamp\": \"$(date -u +%FT%TZ)\"
         }"
}

main() {
    analyze_log
}

main "$@"
```

## Como Usar

1. Instale os agentes:

```BASH
./install_agent.sh
```

1. Configure regras:

```YAML
# analyzer/rules.yaml
rules:
  - name: "Error Detection"
    pattern: "ERROR|FATAL|CRITICAL"
    action: "email"
  - name: "Security Alert"
    pattern: "unauthorized|forbidden|invalid"
    action: "slack"
```

1. Inicie o sistema:

```BASH
./start_collector.sh
./start_analyzer.sh
```

## Recursos Avançados

* Coleta distribuída

* Parsing inteligente

* Análise em tempo real

* Alertas customizáveis

* Dashboard web

* Armazenamento eficiente



